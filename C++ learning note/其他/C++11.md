C++11 是 C++ 编程语言的一个重要标准，由 ISO/IEC 于 2011 年发布，全称为 ISO/IEC 14882:2011。它引入了许多新特性，显著提升了代码的简洁性、性能和功能。以下是 C++11 的主要特性：

### 1. **自动类型推导**
   - **`auto` 关键字**：编译器自动推断变量类型。
     ```cpp
     auto x = 10; // x 的类型为 int
     ```

### 2. **基于范围的 for 循环**
   - 简化容器遍历。
     ```cpp
     std::vector<int> v = {1, 2, 3};
     for (auto i : v) {
         std::cout << i << std::endl;
     }
     ```

### 3. **智能指针**
   - **`std::unique_ptr`**：独占所有权的智能指针。
   - **`std::shared_ptr`**：支持多个指针共享所有权。
   - **`std::weak_ptr`**：避免 `shared_ptr` 的循环引用。
     ```cpp
     std::unique_ptr<int> ptr(new int(10));
     ```

### 4. **Lambda 表达式**
   - 支持匿名函数。
     ```cpp
     auto func = [](int x) { return x * x; };
     std::cout << func(5) << std::endl; // 输出 25
     ```

### 5. **右值引用和移动语义**
   - **右值引用 (`&&`)**：支持移动语义，提升性能。
     ```cpp
     std::string str1 = "Hello";
     std::string str2 = std::move(str1); // str1 的资源被移动到 str2
     ```

### 6. **`nullptr` 关键字**
   - 替代 `NULL`，表示空指针。
     ```cpp
     int* ptr = nullptr;
     ```

### 7. **强类型枚举**
   - **`enum class`**：避免传统枚举的作用域污染。
     ```cpp
     enum class Color { Red, Green, Blue };
     Color c = Color::Red;
     ```

### 8. **`constexpr` 关键字**
   - 编译时计算常量表达式。
     ```cpp
     constexpr int square(int x) {
         return x * x;
     }
     int arr[square(3)]; // arr 的大小为 9
     ```

### 9. **初始化列表**
   - 统一初始化语法。
     ```cpp
     std::vector<int> v = {1, 2, 3, 4};
     ```

### 10. **委托构造函数**
   - 一个构造函数调用另一个构造函数。
     ```cpp
     class MyClass {
     public:
         MyClass(int x) : MyClass(x, 0) {}
         MyClass(int x, int y) : x(x), y(y) {}
     private:
         int x, y;
     };
     ```

### 11. **`override` 和 `final` 关键字**
   - **`override`**：显式标记重写虚函数。
   - **`final`**：禁止派生类重写虚函数或继承类。
     ```cpp
     class Base {
     public:
         virtual void func() {}
     };
     class Derived : public Base {
     public:
         void func() override {}
     };
     ```

### 12. **多线程支持**
   - 标准库引入多线程支持，包括线程、互斥量、条件变量等。
     ```cpp
     #include <thread>
     void task() {
         std::cout << "Hello from thread!" << std::endl;
     }
     std::thread t(task);
     t.join();
     ```

### 13. **`std::array`**
   - 固定大小的数组容器。
     ```cpp
     std::array<int, 3> arr = {1, 2, 3};
     ```

### 14. **`std::tuple`**
   - 支持存储多个不同类型的元素。
     ```cpp
     std::tuple<int, double, std::string> t(1, 2.0, "three");
     ```

### 15. **`std::function` 和 `std::bind`**
   - **`std::function`**：通用函数包装器。
   - **`std::bind`**：绑定函数参数。
     ```cpp
     std::function<int(int, int)> add = [](int a, int b) { return a + b; };
     std::cout << add(2, 3) << std::endl; // 输出 5
     ```

### 16. **`std::unordered_map` 和 `std::unordered_set`**
   - 基于哈希表的无序容器。
     ```cpp
     std::unordered_map<std::string, int> umap = {{"one", 1}, {"two", 2}};
     ```

### 17. **`std::forward_list`**
   - 单向链表。
     ```cpp
     std::forward_list<int> flist = {1, 2, 3};
     ```

### 18. **`std::chrono`**
   - 时间库，支持高精度计时。
     ```cpp
     auto start = std::chrono::high_resolution_clock::now();
     // 一些操作
     auto end = std::chrono::high_resolution_clock::now();
     std::chrono::duration<double> elapsed = end - start;
     std::cout << "Elapsed time: " << elapsed.count() << " seconds" << std::endl;
     ```

### 19. **`std::regex`**
   - 正则表达式支持。
     ```cpp
     std::regex pattern("\\d+");
     std::string text = "123 abc";
     if (std::regex_search(text, pattern)) {
         std::cout << "Found a number!" << std::endl;
     }
     ```

### 20. **`alignas` 和 `alignof`**
   - 控制内存对齐。
     ```cpp
     alignas(16) int arr[4]; // arr 按 16 字节对齐
     std::cout << alignof(arr) << std::endl; // 输出 16
     ```

### 21. **`std::initializer_list`**
   - 支持初始化列表。
     ```cpp
     void func(std::initializer_list<int> list) {
         for (auto i : list) {
             std::cout << i << std::endl;
         }
     }
     func({1, 2, 3});
     ```

### 22. **`std::to_string`**
   - 将数值转换为字符串。
     ```cpp
     std::string str = std::to_string(123);
     ```

### 23. **`std::stoi`, `std::stol`, `std::stoll` 等**
   - 字符串转换为数值。
     ```cpp
     int num = std::stoi("123");
     ```

### 24. **`std::thread_local`**
   - 线程局部存储。
     ```cpp
     thread_local int thread_specific_value = 0;
     ```

### 25. **`std::atomic`**
   - 原子操作支持。
     ```cpp
     std::atomic<int> atomic_value(0);
     atomic_value.fetch_add(1);
     ```

### 26. **`std::quick_exit` 和 `std::at_quick_exit`**
   - 快速退出程序。
     ```cpp
     std::at_quick_exit([]() {
         std::cout << "Quick exit!" << std::endl;
     });
     std::quick_exit(0);
     ```

### 27. **`std::result_of`**
   - 推断函数调用结果类型。
     ```cpp
     template<typename F, typename... Args>
     void call(F f, Args... args) {
         typename std::result_of<F(Args...)>::type result = f(args...);
         std::cout << result << std::endl;
     }
     ```

### 28. **`std::is_same`**
   - 类型比较。
     ```cpp
     static_assert(std::is_same<int, int>::value, "Types are not the same");
     ```

### 29. **`std::enable_if`**
   - 条件编译。
     ```cpp
     template<typename T, typename = std::enable_if<std::is_integral<T>::value>::type>
     void func(T x) {
         std::cout << "Integral type" << std::endl;
     }
     ```

### 30. **`std::declval`**
   - 在不创建对象的情况下推断类型。
     ```cpp
     template<typename T>
     void func() {
         decltype(std::declval<T>().some_function()) result;
     }
     ```

### 总结
C++11 通过引入这些新特性，显著提升了代码的简洁性、性能和功能，成为现代 C++ 开发的重要基础。