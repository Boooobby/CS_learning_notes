`nullptr` 和 `NULL` 都用于表示空指针，但它们在 C++ 中有一些关键的区别。以下是它们之间的主要差异：

### 1. **类型安全性**：

- **`nullptr`**：
  - `nullptr` 是 C++11 引入的关键字，它是一个特定类型的常量，专门用于表示空指针。
  - 它的类型是 `std::nullptr_t`，并且被设计为指针类型的通用空值。
  - 由于它是类型安全的，编译器能够确保 `nullptr` 只用于指针类型，这可以防止类型转换错误。
  - 使用 `nullptr` 时，编译器能够根据上下文推断出它应该作为哪个类型的空指针。

  ```cpp
  int* p = nullptr;  // p 是一个指向 int 类型的空指针
  ```

- **`NULL`**：
  - `NULL` 是一个宏，通常定义为 `0` 或 `(void*)0`，表示空指针。
  - 它没有专门的类型，因此它可以在某些情况下引起类型转换的歧义。
  - `NULL` 在 C++ 中也可以用于任何类型的指针，但它在某些情况下可能导致类型不匹配的问题。
  
  ```cpp
  int* p = NULL;  // p 是一个指向 int 类型的空指针
  ```

  `NULL` 可能会被编译器当作 `0` 或 `(void*)0` 处理，这在某些上下文中会引起类型转换的问题。

### 2. **类型推断**：

- **`nullptr`**：
  - `nullptr` 是类型安全的，可以推导出正确的指针类型。它不容易引发类型推导错误。
  
  ```cpp
  void* ptr = nullptr;  // 正确，ptr 是一个 void 类型的空指针
  int* ptr2 = nullptr;  // 正确，ptr2 是一个 int 类型的空指针
  ```

- **`NULL`**：
  - `NULL` 是一个常量值（通常是 `0`），它在编译器眼中是一个整数常量，因此在某些情况下，编译器可能将它解释为 `0`，这可能导致类型推导错误。

  ```cpp
  void* ptr = NULL;  // 正确，ptr 是一个 void 类型的空指针
  int* ptr2 = NULL;  // 正确，ptr2 是一个 int 类型的空指针
  ```

  但是如果使用 `NULL` 时，指针类型不能明确时，可能会导致意外的类型转换。

### 3. **在函数重载中的区别**：

由于 `NULL` 只是 `0`，它可能引起函数重载中的歧义。比如在函数重载时，如果使用 `NULL`，编译器可能无法决定该调用哪个重载版本。使用 `nullptr` 则可以避免这种问题，因为它明确是指针类型。

```cpp
void foo(int) { std::cout << "foo(int)\n"; }
void foo(void*) { std::cout << "foo(void*)\n"; }

int main() {
    foo(NULL);      // 可能调用 foo(int)，可能不确定
    foo(nullptr);   // 明确调用 foo(void*)
}
```

### 4. **兼容性**：

- **`NULL`**：
  - `NULL` 是 C 语言的产物，因此在 C 和 C++ 中都可以使用。它在较旧的 C++ 编译器中也支持。
  
- **`nullptr`**：
  - `nullptr` 是 C++11 引入的，老旧的 C++ 编译器（C++03及之前）不支持 `nullptr`，而只能使用 `NULL`。

### 5. **值的不同**：

- **`nullptr`** 的值是一个独特的常量（其类型是 `std::nullptr_t`），而不是 `0` 或 `(void*)0`。
- **`NULL`** 在大多数实现中是 `0`，或是 `((void*)0)`，这取决于平台。

### 总结：
- **`nullptr`** 是现代 C++ 的标准，类型安全、明确、不易引起歧义。
- **`NULL`** 是旧的 C 风格的空指针常量，可能在某些情况下导致类型推导错误和重载歧义。

**推荐使用 `nullptr`**，尤其是在 C++11 及之后的版本中，因为它提供了更好的类型安全性和明确性。