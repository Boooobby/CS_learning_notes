在 C++ 中，如果你在堆区开辟的内存没有初始化，其值是 **未定义的**，也就是垃圾值。这是因为堆内存（由 `new` 或 `malloc` 等分配的内存）不会自动初始化其内容。分配的内存中存储的是上一次使用该内存区域的数据或者系统环境中的随机值。

### 具体情况：

1. **使用 `new` 分配内存**：
   - **原始指针**：如果你通过 `new` 来分配内存，但没有指定初始化值，内存中的数据就是未定义的。这些数据是无法预测的，通常是 "随机" 的，取决于操作系统和堆的状态。

   ```cpp
   int* ptr = new int;  // ptr 指向堆上的一个 int
   // 这里的 *ptr 是未定义的
   ```

   这里，`ptr` 指向堆上的一个 `int` 类型的内存位置，但它没有被初始化，所以 `*ptr` 的值是不可预测的。

2. **使用 `new[]` 分配数组**：
   - **未初始化的数组**：如果使用 `new[]` 来分配数组，但没有初始化数组元素，它们的内容也是未定义的。

   ```cpp
   int* arr = new int[5];  // 创建一个长度为 5 的 int 数组
   // arr[i] 中的值是未定义的
   ```

   这意味着 `arr[0]`、`arr[1]` 等数组元素包含的值是垃圾值，不会是 0 或任何确定的值，直到你显式地给它们赋值。

3. **初始化的行为**：
   - **值类型**（如 `int`、`double` 等）在 `new` 分配时不进行初始化。
   - 如果你希望分配的内存初始化为某个值，可以使用初始化表达式：
     ```cpp
     int* ptr = new int(0);  // 初始化为 0
     ```

4. **对类类型的初始化**：
   - 如果你用 `new` 创建一个类对象（例如 `new Worker`），而没有显式初始化该对象，它的成员变量的值是未定义的，除非类有默认构造函数。
     ```cpp
     Worker* worker = new Worker();  // 使用默认构造函数初始化对象
     ```
   - 如果没有提供默认构造函数或初始化逻辑，那么类的成员变量会保持未定义状态。

### 总结：
- **堆内存分配后不初始化**：未初始化的堆内存包含垃圾值，访问它们会导致不可预测的行为。
- **推荐做法**：在堆内存分配后尽量初始化内存，或者显式地设置为需要的默认值。如果你不初始化它们，那么在访问时就会导致错误，甚至可能引发崩溃或数据不一致等问题。