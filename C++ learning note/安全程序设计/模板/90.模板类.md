好的，我们来详细讲解一下 C++ 中的模板类。

模板类是 C++ 泛型编程的核心，它允许你编写一个可以处理多种数据类型的类，而无需为每种类型都重写一遍代码。简单来说，**模板类是一个“类工厂”，你可以通过指定数据类型来“生产”出具体的类**。

---

### 1. 为什么需要模板类？

假设你需要一个能够存储整数的 `Box` 类，你可能会这样写：

```cpp
class IntBox {
private:
    int value;
public:
    IntBox(int v) : value(v) {}
    int getValue() const { return value; }
    void setValue(int v) { value = v; }
};
```

但很快，你又需要一个存储字符串的 `Box` 类：

```cpp
class StringBox {
private:
    std::string value;
public:
    StringBox(std::string v) : value(v) {}
    std::string getValue() const { return value; }
    void setValue(std::string v) { value = v; }
};
```

你会发现，除了数据类型（`int` vs `std::string`），这两个类的代码几乎一模一样。这违反了 **DRY（Don‘t Repeat Yourself）** 原则。如果还需要 `DoubleBox`、`FloatBox` 等，代码会变得非常冗余且难以维护。

**模板类就是为了解决这个问题而生的。**

---

### 2. 模板类的基本语法

使用 `template <typename T>` 关键字来声明一个模板。`T` 是一个占位符，代表一种未知的数据类型。

下面是用模板重写的 `Box` 类：

```cpp
// 声明一个模板，T 是模板参数
template <typename T> // 也可以用 template <class T>
class Box {
private:
    T value; // 使用 T 作为类型
public:
    Box(T v) : value(v) {}
    T getValue() const { return value; }
    void setValue(T v) { value = v; }
};
```

**关键点：**
- `template <typename T>` 或 `template <class T>` 告诉编译器下面将要定义一个模板。`typename` 和 `class` 在这里可以互换，但 `typename` 通常更直观。
- `T` 可以是任何有效的标识符（如 `Type`, `Elem` 等），但 `T` 是约定俗成的名字。
- 在类内部，凡是需要用到具体类型的地方，都用 `T` 来代替。

---

### 3. 如何使用模板类（实例化）

模板类本身不是一个真正的类，它只是一个蓝图。要使用它，你必须进行 **实例化（Instantiation）**，即提供一个具体的类型来替换 `T`。

**语法：`ClassName<Type> objectName(parameters);`**

```cpp
#include <iostream>
#include <string>

int main() {
    // 实例化一个存储 int 的 Box 类
    Box<int> intBox(123);
    std::cout << intBox.getValue() << std::endl; // 输出：123

    // 实例化一个存储 std::string 的 Box 类
    Box<std::string> stringBox("Hello, Template!");
    std::cout << stringBox.getValue() << std::endl; // 输出：Hello, Template!

    // 实例化一个存储 double 的 Box 类
    Box<double> doubleBox(3.14159);
    std::cout << doubleBox.getValue() << std::endl; // 输出：3.14159

    return 0;
}
```

当编译器看到 `Box<int>` 时，它会根据模板 `Box<T>` 的蓝图，生成一个专门处理 `int` 类型的类代码。这个过程叫做 **模板实例化**。

---

### 4. 模板类的成员函数在类外定义

如果成员函数在类模板的外部定义，语法会稍微复杂一些，因为每个函数都需要自己声明为模板函数。

```cpp
template <typename T>
class Box {
private:
    T value;
public:
    Box(T v);
    T getValue() const;
    void setValue(T v);
};

// 构造函数在类外定义
template <typename T>
Box<T>::Box(T v) : value(v) {}

// 普通成员函数在类外定义
template <typename T>
T Box<T>::getValue() const {
    return value;
}

template <typename T>
void Box<T>::setValue(T v) {
    value = v;
}
```

**注意：**
- 每个成员函数定义前都必须加上 `template <typename T>`。
- 类名不再是简单的 `Box`，而是 `Box<T>`。
- 模板类的声明和定义通常都放在头文件（`.h` 或 `.hpp`）中。这是因为编译器需要在实例化时看到完整的定义。如果将定义放在 `.cpp` 文件中，在链接时可能会找不到符号。

---

### 5. 多个模板参数

模板可以接受多个参数，用逗号分隔。

```cpp
template <typename T, typename U>
class Pair {
private:
    T first;
    U second;
public:
    Pair(const T& f, const U& s) : first(f), second(s) {}
    T getFirst() const { return first; }
    U getSecond() const { return second; }
};

// 使用
int main() {
    Pair<int, std::string> student(101, "Alice");
    Pair<std::string, double> currency("USD", 7.25);

    std::cout << student.getFirst() << ": " << student.getSecond() << std::endl;
    return 0;
}
```

---

### 6. 非类型模板参数

模板参数不一定都是类型，也可以是整型、指针、引用等（必须是编译时常量）。

```cpp
// 一个固定大小的数组类
template <typename T, int Size>
class FixedArray {
private:
    T data[Size]; // 数组大小在编译时确定
public:
    T& operator[](int index) {
        return data[index];
    }
    int getSize() const { return Size; }
};

// 使用
int main() {
    FixedArray<int, 5> intArray; // 创建一个大小为5的int数组
    FixedArray<double, 10> doubleArray; // 创建一个大小为10的double数组

    for (int i = 0; i < intArray.getSize(); ++i) {
        intArray[i] = i * i;
    }
    return 0;
}
```

---

### 7. 模板特化

有时，对于特定的数据类型，你可能希望模板类有不同的行为。这时可以使用 **模板特化（Template Specialization）**。

```cpp
// 通用的模板类
template <typename T>
class Printer {
public:
    void print(T value) {
        std::cout << "Value: " << value << std::endl;
    }
};

// 特化版本，针对 const char* 类型
template <>
class Printer<const char*> {
public:
    void print(const char* value) {
        std::cout << "C-string: \"" << value << "\"" << std::endl;
    }
};

// 使用
int main() {
    Printer<int> intPrinter;
    intPrinter.print(42); // 输出：Value: 42

    Printer<const char*> strPrinter;
    strPrinter.print("Hello"); // 输出：C-string: "Hello"

    return 0;
}
```

---

### 总结

| 特性 | 描述 | 示例 |
| :--- | :--- | :--- |
| **基本语法** | 使用 `template <typename T>` 声明 | `template <typename T> class MyClass {...};` |
| **实例化** | 用具体类型替换 `T` | `MyClass<int> obj;` |
| **外部定义** | 成员函数定义需包含模板头 | `template <typename T> T MyClass<T>::get() {...}` |
| **多参数** | 支持多个类型参数 | `template <typename T, typename U> class Pair {...}` |
| **非类型参数** | 参数可以是值（编译时常量） | `template <typename T, int Size> class Array {...}` |
| **特化** | 为特定类型提供特殊实现 | `template <> class MyClass<std::string> {...}` |

**模板类的优点：**
1.  **类型安全**：比使用 `void*` 的通用容器更安全。
2.  **代码复用**：编写一次，用于多种类型。
3.  **性能**：在编译时进行类型绑定，没有运行时开销（与虚函数相比）。

**模板类的缺点：**
1.  **编译错误信息晦涩**：模板的错误信息可能非常长且难以理解。
2.  **代码膨胀**：每个不同的实例化都会生成一份代码，可能增加可执行文件的大小。
3.  **编译时间**：模板通常在头文件中，每次包含都需要重新编译，可能增加编译时间。

模板类是 C++ 标准库（如 `vector`, `map`, `list` 等）的基石，理解它们是成为高级 C++ 程序员的关键一步。希望这个讲解对你有帮助！