好的，我来详细讲解 STL 算法部分。STL 算法是非常强大的工具，它们通过迭代器与容器协作，提供了丰富的通用操作。

## 1. 算法基础

STL 算法都定义在 `<algorithm>` 头文件中，它们通过迭代器操作容器元素。

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 9, 3};
    
    // 大多数算法接受迭代器范围 [first, last)
    std::sort(vec.begin(), vec.end()); // 排序
    
    // 遍历输出
    for (int x : vec) {
        std::cout << x << " "; // 1 2 3 5 8 9
    }
    
    return 0;
}
```

## 2. 非修改序列算法

这些算法不会改变容器内容，主要用于查询和检查。

### find 系列

```cpp
#include <algorithm>
#include <vector>
#include <list>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 2, 6};
    std::list<std::string> lst = {"apple", "banana", "cherry"};
    
    // find - 查找单个元素
    auto it1 = std::find(vec.begin(), vec.end(), 3);
    if (it1 != vec.end()) {
        std::cout << "找到3，位置: " << (it1 - vec.begin()) << std::endl;
    }
    
    // find_if - 按条件查找
    auto it2 = std::find_if(vec.begin(), vec.end(), [](int x) {
        return x % 2 == 0 && x > 3;
    });
    if (it2 != vec.end()) {
        std::cout << "找到第一个大于3的偶数: " << *it2 << std::endl;
    }
    
    // find_if_not - 查找不满足条件的元素
    auto it3 = std::find_if_not(vec.begin(), vec.end(), [](int x) {
        return x < 4;
    });
    if (it3 != vec.end()) {
        std::cout << "找到第一个不小于4的元素: " << *it3 << std::endl;
    }
    
    return 0;
}
```

### count 系列

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 2, 4, 2, 5, 2};
    
    // count - 统计特定元素出现次数
    int count_2 = std::count(vec.begin(), vec.end(), 2);
    std::cout << "2出现的次数: " << count_2 << std::endl;
    
    // count_if - 按条件统计
    int count_even = std::count_if(vec.begin(), vec.end(), [](int x) {
        return x % 2 == 0;
    });
    std::cout << "偶数个数: " << count_even << std::endl;
    
    return 0;
}
```

### 搜索算法

```cpp
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8};
    std::vector<int> sub = {3, 4, 5};
    std::string str = "hello world";
    
    // search - 在序列中查找子序列
    auto it1 = std::search(vec.begin(), vec.end(), sub.begin(), sub.end());
    if (it1 != vec.end()) {
        std::cout << "找到子序列，起始位置: " << (it1 - vec.begin()) << std::endl;
    }
    
    // find_end - 从后往前查找子序列
    std::vector<int> vec2 = {1, 2, 3, 4, 1, 2, 3};
    std::vector<int> sub2 = {1, 2, 3};
    auto it2 = std::find_end(vec2.begin(), vec2.end(), sub2.begin(), sub2.end());
    if (it2 != vec2.end()) {
        std::cout << "从后往前找到子序列，位置: " << (it2 - vec2.begin()) << std::endl;
    }
    
    // find_first_of - 查找第一个匹配任意给定元素的元素
    std::vector<int> targets = {4, 6, 8};
    auto it3 = std::find_first_of(vec.begin(), vec.end(), targets.begin(), targets.end());
    if (it3 != vec.end()) {
        std::cout << "找到第一个匹配目标: " << *it3 << std::endl;
    }
    
    return 0;
}
```

### 比较算法

```cpp
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {1, 2, 3, 4, 5};
    std::vector<int> vec3 = {1, 2, 3, 4, 6};
    
    // equal - 判断两个序列是否相等
    bool is_equal = std::equal(vec1.begin(), vec1.end(), vec2.begin());
    std::cout << "vec1 和 vec2 是否相等: " << is_equal << std::endl;
    
    // mismatch - 查找第一个不同的位置
    auto mismatch_pair = std::mismatch(vec1.begin(), vec1.end(), vec3.begin());
    if (mismatch_pair.first != vec1.end()) {
        std::cout << "第一个不同的位置: " << *mismatch_pair.first 
                  << " vs " << *mismatch_pair.second << std::endl;
    }
    
    // lexicographical_compare - 字典序比较
    std::string str1 = "apple";
    std::string str2 = "banana";
    bool is_less = std::lexicographical_compare(str1.begin(), str1.end(),
                                               str2.begin(), str2.end());
    std::cout << str1 << " 在字典序中是否小于 " << str2 << ": " << is_less << std::endl;
    
    return 0;
}
```

## 3. 修改序列算法

这些算法会修改容器内容。

### copy 系列

```cpp
#include <algorithm>
#include <vector>
#include <list>
#include <iterator>
#include <iostream>

int main() {
    std::vector<int> src = {1, 2, 3, 4, 5};
    std::vector<int> dest1(5);
    std::list<int> dest2;
    
    // copy - 复制序列
    std::copy(src.begin(), src.end(), dest1.begin());
    std::cout << "复制后的vector: ";
    for (int x : dest1) std::cout << x << " ";
    std::cout << std::endl;
    
    // copy_if - 条件复制
    std::copy_if(src.begin(), src.end(), std::back_inserter(dest2), [](int x) {
        return x % 2 == 1; // 只复制奇数
    });
    std::cout << "复制奇数到list: ";
    for (int x : dest2) std::cout << x << " ";
    std::cout << std::endl;
    
    // copy_n - 复制前n个元素
    std::vector<int> dest3;
    std::copy_n(src.begin(), 3, std::back_inserter(dest3));
    std::cout << "复制前3个元素: ";
    for (int x : dest3) std::cout << x << " ";
    std::cout << std::endl;
    
    return 0;
}
```

### transform - 转换元素

```cpp
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>
#include <cctype>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    std::vector<int> squares;
    std::vector<std::string> words = {"hello", "world", "cpp"};
    std::vector<std::string> upper_words;
    
    // 一元transform - 对每个元素应用函数
    std::transform(numbers.begin(), numbers.end(), 
                   std::back_inserter(squares),
                   [](int x) { return x * x; });
    
    std::cout << "平方数: ";
    for (int x : squares) std::cout << x << " ";
    std::cout << std::endl;
    
    // 字符串转大写
    std::transform(words.begin(), words.end(),
                   std::back_inserter(upper_words),
                   [](const std::string& s) {
                       std::string result = s;
                       for (char& c : result) {
                           c = std::toupper(c);
                       }
                       return result;
                   });
    
    std::cout << "大写单词: ";
    for (const auto& w : upper_words) std::cout << w << " ";
    std::cout << std::endl;
    
    // 二元transform - 合并两个序列
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {10, 20, 30, 40, 50};
    std::vector<int> sums;
    
    std::transform(vec1.begin(), vec1.end(), vec2.begin(),
                   std::back_inserter(sums),
                   [](int a, int b) { return a + b; });
    
    std::cout << "对应元素和: ";
    for (int x : sums) std::cout << x << " ";
    std::cout << std::endl;
    
    return 0;
}
```

### fill 和 generate

```cpp
#include <algorithm>
#include <vector>
#include <iostream>
#include <random>

int main() {
    std::vector<int> vec(5);
    
    // fill - 填充相同值
    std::fill(vec.begin(), vec.end(), 42);
    std::cout << "填充42后: ";
    for (int x : vec) std::cout << x << " ";
    std::cout << std::endl;
    
    // fill_n - 填充前n个元素
    std::vector<int> vec2(10);
    std::fill_n(vec2.begin(), 5, 100);
    std::cout << "前5个填充100: ";
    for (int x : vec2) std::cout << x << " ";
    std::cout << std::endl;
    
    // generate - 用生成器函数填充
    std::vector<int> vec3(5);
    int counter = 1;
    std::generate(vec3.begin(), vec3.end(), [&counter]() {
        return counter++ * 10;
    });
    std::cout << "生成序列: ";
    for (int x : vec3) std::cout << x << " ";
    std::cout << std::endl;
    
    return 0;
}
```

### remove 系列

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 2, 4, 2, 5, 2};
    
    std::cout << "原始序列: ";
    for (int x : vec) std::cout << x << " ";
    std::cout << std::endl;
    
    // remove 并不真正删除元素，而是把要保留的元素移到前面
    auto new_end = std::remove(vec.begin(), vec.end(), 2);
    
    std::cout << "remove后: ";
    for (int x : vec) std::cout << x << " ";
    std::cout << std::endl;
    
    // 真正删除需要结合erase
    vec.erase(new_end, vec.end());
    std::cout << "erase后: ";
    for (int x : vec) std::cout << x << " ";
    std::cout << std::endl;
    
    // remove_if - 条件删除
    std::vector<int> vec2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    auto new_end2 = std::remove_if(vec2.begin(), vec2.end(), [](int x) {
        return x % 2 == 0; // 删除偶数
    });
    vec2.erase(new_end2, vec2.end());
    std::cout << "删除偶数后: ";
    for (int x : vec2) std::cout << x << " ";
    std::cout << std::endl;
    
    return 0;
}
```

### replace 系列

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 2, 4, 2, 5};
    
    // replace - 替换特定值
    std::replace(vec.begin(), vec.end(), 2, 99);
    std::cout << "替换2为99: ";
    for (int x : vec) std::cout << x << " ";
    std::cout << std::endl;
    
    // replace_if - 条件替换
    std::vector<int> vec2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    std::replace_if(vec2.begin(), vec2.end(), [](int x) {
        return x % 2 == 0;
    }, 0); // 把所有偶数替换为0
    
    std::cout << "偶数替换为0: ";
    for (int x : vec2) std::cout << x << " ";
    std::cout << std::endl;
    
    return 0;
}
```

## 4. 排序和相关算法

### 排序算法

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    
    // sort - 快速排序
    std::sort(vec.begin(), vec.end());
    std::cout << "升序排序: ";
    for (int x : vec) std::cout << x << " ";
    std::cout << std::endl;
    
    // 自定义比较函数
    std::sort(vec.begin(), vec.end(), [](int a, int b) {
        return a > b; // 降序
    });
    std::cout << "降序排序: ";
    for (int x : vec) std::cout << x << " ";
    std::cout << std::endl;
    
    // stable_sort - 稳定排序（保持相等元素的相对顺序）
    std::vector<std::pair<int, char>> pairs = {
        {1, 'a'}, {2, 'b'}, {1, 'c'}, {3, 'd'}, {2, 'e'}
    };
    
    std::stable_sort(pairs.begin(), pairs.end(), 
                    [](const auto& a, const auto& b) {
                        return a.first < b.first;
                    });
    
    std::cout << "稳定排序后: ";
    for (const auto& p : pairs) {
        std::cout << "(" << p.first << "," << p.second << ") ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 二分查找算法（必须在有序序列上使用）

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // binary_search - 检查元素是否存在
    bool found = std::binary_search(vec.begin(), vec.end(), 5);
    std::cout << "5是否存在: " << found << std::endl;
    
    // lower_bound - 找到第一个不小于给定值的元素位置
    auto lower = std::lower_bound(vec.begin(), vec.end(), 5);
    std::cout << "第一个不小于5的元素: " << *lower << " 位置: " 
              << (lower - vec.begin()) << std::endl;
    
    // upper_bound - 找到第一个大于给定值的元素位置
    auto upper = std::upper_bound(vec.begin(), vec.end(), 5);
    std::cout << "第一个大于5的元素: " << *upper << " 位置: " 
              << (upper - vec.begin()) << std::endl;
    
    // equal_range - 返回等于给定值的范围 [lower_bound, upper_bound)
    auto range = std::equal_range(vec.begin(), vec.end(), 5);
    std::cout << "等于5的元素范围大小: " << (range.second - range.first) << std::endl;
    
    return 0;
}
```

### 合并算法

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec1 = {1, 3, 5, 7, 9};
    std::vector<int> vec2 = {2, 4, 6, 8, 10};
    std::vector<int> merged(10);
    
    // merge - 合并两个有序序列
    std::merge(vec1.begin(), vec1.end(),
               vec2.begin(), vec2.end(),
               merged.begin());
    
    std::cout << "合并后: ";
    for (int x : merged) std::cout << x << " ";
    std::cout << std::endl;
    
    // inplace_merge - 原地合并（用于归并排序）
    std::vector<int> vec3 = {1, 3, 5, 2, 4, 6};
    std::inplace_merge(vec3.begin(), vec3.begin() + 3, vec3.end());
    std::cout << "原地合并: ";
    for (int x : vec3) std::cout << x << " ";
    std::cout << std::endl;
    
    return 0;
}
```

## 5. 分区算法

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // partition - 按条件分区
    auto boundary = std::partition(vec.begin(), vec.end(), [](int x) {
        return x % 2 == 0; // 偶数在前，奇数在后
    });
    
    std::cout << "分区后: ";
    for (int x : vec) std::cout << x << " ";
    std::cout << std::endl;
    
    std::cout << "分界点位置: " << (boundary - vec.begin()) << std::endl;
    std::cout << "前半部分（满足条件）: ";
    for (auto it = vec.begin(); it != boundary; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    
    // is_partitioned - 检查是否已分区
    bool is_part = std::is_partitioned(vec.begin(), vec.end(), [](int x) {
        return x % 2 == 0;
    });
    std::cout << "是否已分区: " << is_part << std::endl;
    
    return 0;
}
```

## 6. 堆算法

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {3, 1, 4, 1, 5, 9, 2, 6};
    
    // make_heap - 构建最大堆
    std::make_heap(vec.begin(), vec.end());
    std::cout << "最大堆: ";
    for (int x : vec) std::cout << x << " ";
    std::cout << std::endl;
    
    // push_heap - 添加元素到堆
    vec.push_back(8);
    std::push_heap(vec.begin(), vec.end());
    std::cout << "添加8后的堆: ";
    for (int x : vec) std::cout << x << " ";
    std::cout << std::endl;
    
    // pop_heap - 从堆中移除最大元素
    std::pop_heap(vec.begin(), vec.end());
    vec.pop_back();
    std::cout << "移除最大元素后: ";
    for (int x : vec) std::cout << x << " ";
    std::cout << std::endl;
    
    // sort_heap - 堆排序
    std::sort_heap(vec.begin(), vec.end());
    std::cout << "堆排序后: ";
    for (int x : vec) std::cout << x << " ";
    std::cout << std::endl;
    
    return 0;
}
```

## 7. 数值算法（在 `<numeric>` 中）

```cpp
#include <numeric>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    // accumulate - 累加
    int sum = std::accumulate(vec.begin(), vec.end(), 0);
    std::cout << "总和: " << sum << std::endl;
    
    // 带自定义操作的accumulate
    int product = std::accumulate(vec.begin(), vec.end(), 1, 
                                 [](int a, int b) { return a * b; });
    std::cout << "乘积: " << product << std::endl;
    
    // inner_product - 内积
    std::vector<int> vec1 = {1, 2, 3};
    std::vector<int> vec2 = {4, 5, 6};
    int dot_product = std::inner_product(vec1.begin(), vec1.end(),
                                        vec2.begin(), 0);
    std::cout << "内积: " << dot_product << std::endl;
    
    // partial_sum - 部分和
    std::vector<int> result(vec.size());
    std::partial_sum(vec.begin(), vec.end(), result.begin());
    std::cout << "部分和: ";
    for (int x : result) std::cout << x << " ";
    std::cout << std::endl;
    
    // adjacent_difference - 相邻差
    std::vector<int> diff(vec.size());
    std::adjacent_difference(vec.begin(), vec.end(), diff.begin());
    std::cout << "相邻差: ";
    for (int x : diff) std::cout << x << " ";
    std::cout << std::endl;
    
    return 0;
}
```

## 8. 最小/最大值算法

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {3, 1, 4, 1, 5, 9, 2, 6};
    
    // min/max 元素
    auto min_it = std::min_element(vec.begin(), vec.end());
    auto max_it = std::max_element(vec.begin(), vec.end());
    std::cout << "最小值: " << *min_it << " 位置: " << (min_it - vec.begin()) << std::endl;
    std::cout << "最大值: " << *max_it << " 位置: " << (max_it - vec.begin()) << std::endl;
    
    // minmax_element - 同时找到最小和最大值
    auto minmax = std::minmax_element(vec.begin(), vec.end());
    std::cout << "最小值: " << *minmax.first << ", 最大值: " << *minmax.second << std::endl;
    
    // 比较多个值
    int a = 5, b = 3, c = 7;
    int min_val = std::min({a, b, c}); // C++11 支持初始化列表
    int max_val = std::max({a, b, c});
    std::cout << "min(5,3,7) = " << min_val << ", max(5,3,7) = " << max_val << std::endl;
    
    return 0;
}
```

## 9. 排列算法

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    
    std::cout << "所有排列:" << std::endl;
    do {
        for (int x : vec) std::cout << x << " ";
        std::cout << std::endl;
    } while (std::next_permutation(vec.begin(), vec.end()));
    
    // 恢复原始顺序
    std::sort(vec.begin(), vec.end());
    
    // 上一个排列
    std::prev_permutation(vec.begin(), vec.end());
    std::cout << "上一个排列: ";
    for (int x : vec) std::cout << x << " ";
    std::cout << std::endl;
    
    return 0;
}
```

## 10. 算法使用技巧和最佳实践

### 使用 lambda 表达式

```cpp
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>

int main() {
    std::vector<std::string> words = {"apple", "banana", "cherry", "date", "elderberry"};
    
    // 使用lambda表达式作为谓词
    auto long_word = std::find_if(words.begin(), words.end(), [](const std::string& s) {
        return s.length() > 6;
    });
    
    if (long_word != words.end()) {
        std::cout << "找到长单词: " << *long_word << std::endl;
    }
    
    // 统计长度大于5的单词
    int count = std::count_if(words.begin(), words.end(), [](const std::string& s) {
        return s.length() > 5;
    });
    std::cout << "长度大于5的单词个数: " << count << std::endl;
    
    return 0;
}
```

### 算法组合使用

```cpp
#include <algorithm>
#include <vector>
#include <iostream>
#include <iterator>

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 9, 3, 7, 4, 6, 5, 2, 8};
    
    // 组合使用多个算法
    std::vector<int> result;
    
    // 1. 排序
    std::sort(numbers.begin(), numbers.end());
    
    // 2. 去重
    auto last = std::unique(numbers.begin(), numbers.end());
    
    // 3. 复制到新容器
    std::copy(numbers.begin(), last, std::back_inserter(result));
    
    // 4. 反转
    std::reverse(result.begin(), result.end());
    
    std::cout << "处理后的结果: ";
    for (int x : result) std::cout << x << " ";
    std::cout << std::endl;
    
    return 0;
}
```

## 总结

STL 算法提供了以下优势：

1. **通用性**：通过迭代器工作，适用于各种容器
2. **高效性**：经过高度优化，性能优秀
3. **安全性**：编译时类型检查
4. **可组合性**：算法可以组合使用，实现复杂操作
5. **可读性**：使用标准算法使代码意图更清晰

掌握 STL 算法可以让你写出更简洁、高效和可维护的 C++ 代码！