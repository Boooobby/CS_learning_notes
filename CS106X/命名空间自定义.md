是的！在 C++ 中，你可以**自定义命名空间（namespace）**，这有助于组织代码、避免命名冲突，并提高代码的可维护性。以下是详细指南：

---

### **1. 基本语法**
#### **定义命名空间**
```cpp
namespace MyNamespace {
    // 可以包含变量、函数、类、结构体等
    int value = 42;

    void print() {
        std::cout << "Hello from MyNamespace!" << std::endl;
    }

    class MyClass {
        // 类定义...
    };
}
```

#### **使用命名空间中的成员**
- **通过作用域解析符 `::`**  
  ```cpp
  int main() {
      std::cout << MyNamespace::value << std::endl; // 输出 42
      MyNamespace::print();                         // 调用函数
      MyNamespace::MyClass obj;                     // 实例化类
      return 0;
  }
  ```

- **使用 `using` 声明**（局部或全局引入）  
  ```cpp
  using MyNamespace::print; // 仅引入 print 函数
  print();                 // 直接调用

  using namespace MyNamespace; // 引入整个命名空间（谨慎使用）
  std::cout << value << std::endl; // 直接访问变量
  ```

---

### **2. 嵌套命名空间**
命名空间可以多层嵌套，进一步细分逻辑：
```cpp
namespace Outer {
    namespace Inner {
        void helper() {
            std::cout << "Nested namespace" << std::endl;
        }
    }
}

// 使用
Outer::Inner::helper();
```

---

### **3. 匿名命名空间**
用于限制作用域仅在当前文件内（类似 `static` 关键字）：
```cpp
namespace {
    int localVar = 100; // 仅在当前.cpp文件中可见
}
```

---

### **4. 命名空间的合并**
同一命名空间可以分散在多个文件中，编译器会自动合并：
```cpp
// file1.cpp
namespace MyLib {
    void func1() { ... }
}

// file2.cpp
namespace MyLib {
    void func2() { ... }
}
```

---

### **5. 实际应用示例**
#### **场景：自定义数学库**
```cpp
namespace Math {
    const double PI = 3.1415926;

    double square(double x) {
        return x * x;
    }

    namespace Geometry {
        double circleArea(double r) {
            return PI * square(r);
        }
    }
}

int main() {
    std::cout << Math::Geometry::circleArea(2.0) << std::endl; // 输出 ~12.566
    return 0;
}
```

---

### **6. 注意事项**
1. **避免与标准库冲突**：不要定义与 `std` 同名的命名空间。  
2. **头文件中的命名空间**：  
   - 在头文件中定义命名空间时，确保所有内容都包含在命名空间内。  
   - 避免在头文件中使用 `using namespace ...`（可能污染包含该头文件的源文件）。  
3. **命名空间别名**：长命名空间可以起别名简化：  
   ```cpp
   namespace LongNamespaceName { ... }
   namespace Short = LongNamespaceName; // 别名
   ```

---

### **7. 为什么需要自定义命名空间？**
- **模块化代码**：将功能相关的代码分组。  
- **避免全局污染**：防止变量/函数名与其他库冲突（例如两个库都定义了 `Logger` 类）。  
- **代码可读性**：通过命名空间名称明确功能归属（如 `Network::HttpRequest`）。

---

### **总结**
| 操作                 | 示例代码                          |
|----------------------|-----------------------------------|
| 定义命名空间         | `namespace MyLib { ... }`         |
| 使用成员             | `MyLib::function();`              |
| 嵌套命名空间         | `namespace A { namespace B {}}`   |
| 匿名命名空间         | `namespace { ... }`               |
| 命名空间别名         | `namespace Short = VeryLongName;` |

合理使用命名空间能让你的代码更专业、更易于协作！