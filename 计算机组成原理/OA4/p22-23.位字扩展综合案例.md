非常好！这是一个综合了**位扩展**和**字扩展**的经典实例，完美地展示了如何用小的、现成的芯片来构建计算机所需的大容量主存。我们一步一步来分析。

---

### 第一步：分析需求与计算芯片数量

*   **目标**：构建 `8K × 16位` 的主存储器。
    *   容量：`8K` = 8 × 1024 = 8192 个存储单元。
    *   位宽：每个单元 `16` 位。
*   **现有芯片**：`2114` 芯片，规格为 `1K × 4位`。
    *   容量：`1K` = 1024 个存储单元。
    *   位宽：每个单元 `4` 位。

**计算总需求：**
总比特数需求 / 单芯片比特数 = (8192 单元 × 16 位/单元) / (1024 单元 × 4 位/芯片) = 32 片。

所以，我们需要 **32片** `2114` 芯片。

---

### 第二步：规划扩展方案——先位扩展，再字扩展

这是一个标准的构建思路。

**1. 位扩展（解决“数据位不够宽”的问题）**

*   **目标**：用 `1K × 4位` 的芯片，构造出一个 `1K × 16位` 的存储**模块**。
*   **方法**：将4片2114芯片**并联**，它们共同工作，一次性提供一个16位的数据。
    *   计算：目标位宽 / 芯片位宽 = `16 / 4 = 4` 片。
*   **连接方式（如图上半部分所示）**：
    *   这4片芯片的**地址线 (A0-A9)** 全部并联。
    *   这4片芯片的**读写控制线 (R/W)** 全部并联。
    *   这4片芯片的**片选信号 (CS)** 在此时也先并联起来（因为我们现在只构造一个独立的1K×16模块）。
    *   **数据线**：这是关键！
        *   第1片（1#）负责数据的 **D0 ~ D3** 位。
        *   第2片（2#）负责数据的 **D4 ~ D7** 位。
        *   第3片（3#）负责数据的 **D8 ~ D11** 位。
        *   第4片（4#）负责数据的 **D12 ~ D15** 位。
*   **结果**：我们现在得到了一个 **“1K × 16位”** 的存储模块。这样的模块，我们一共需要 **8个**。

**2. 字扩展（解决“地址空间不够大”的问题）**

*   **目标**：将8个刚才做好的 `1K × 16位` 模块，组合成一个 `8K × 16位` 的完整存储器。
*   **方法**：为这8个模块分配不同的地址范围，通过高位地址线和一个译码器来选择激活哪一个模块。
    *   计算：目标容量 / 模块容量 = `8K / 1K = 8` 个模块。
*   **连接方式（如图下半部分所示）**：
    *   **数据线**：所有8个模块的16位数据线（D0-D15）都**并联**到CPU的16位数据总线上。
    *   **读写控制线 (R/W)**：所有8个模块的读写控制线都**并联**到CPU的R/W控制线上。
    *   **低位地址线**：所有8个模块的地址线 (A0-A9) 都**并联**到CPU地址总线的 A0-A9 上。这10根线用于寻址每个模块内部那1K的空间。
    *   **高位地址线与片选**：这是字扩展的核心。
        *   CPU的地址总线需要有13根来寻址8K的空间 (2^13 = 8192)。
        *   我们用了低10位 (A0-A9) 作为**片内地址**。
        *   剩下的高3位 (A10, A11, A12) 用作**片选地址**。
        *   将这3根地址线 (A10, A11, A12) 输入一个 **3-8译码器**。
        *   译码器的8个输出 (Y0 ~ Y7)，分别连接到**8个存储模块的片选信号 (CS)** 上。

---

### 第三步：理解完整的连接图与地址空间

现在，32片2114芯片被组织成了 **8行 × 4列** 的矩阵：
*   **每一列（4片）** 组成了一个 `1K × 16位` 的模块（位扩展的结果）。
*   **每一行（8个模块）** 覆盖了从 `0` 到 `8K-1` 的整个地址空间（字扩展的结果）。

**地址分配示例：**
*   当 CPU 地址 `A12 A11 A10 = 000` 时，译码器输出 **Y0** 有效，选中第一个存储模块。CPU可以访问这个模块内 `0x0000 ~ 0x03FF` 的地址。
*   当 CPU 地址 `A12 A11 A10 = 001` 时，译码器输出 **Y1** 有效，选中第二个存储模块。CPU可以访问这个模块内 `0x0400 ~ 0x07FF` 的地址。
*   ... 以此类推 ...
*   当 CPU 地址 `A12 A11 A10 = 111` 时，译码器输出 **Y7** 有效，选中最后一个存储模块。CPU可以访问这个模块内 `0x1C00 ~ 0x1FFF` 的地址。

### 总结

这个实例完美地演示了存储器设计的核心思想：
1.  **位扩展（并联）**：解决 **“字长”** 问题。**“统一控制，数据分片”**。
2.  **字扩展（串联）**：解决 **“容量”** 问题。**“数据共享，分区选片”**。

在实际的计算机内存（如SIMM、DIMM内存条）中，正是使用了完全相同的原理，将多颗DRAM芯片组合成所需的容量和位宽。