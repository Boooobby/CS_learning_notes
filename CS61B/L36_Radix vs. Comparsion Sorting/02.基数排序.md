好的，我们来详细讲解**基数排序**，这是一种非常巧妙的非比较排序算法。

## 1. 核心思想

基数排序的基本思想：**按位排序，从最低位到最高位**。

就像整理一堆不同长度的字符串：
- 先按最后一个字母排序
- 再按倒数第二个字母排序
- 依此类推，直到第一个字母

对于数字也是同样的道理：先按个位，再按十位，再按百位...

## 2. 算法步骤

### LSD（最低位优先）基数排序步骤：

1. **找到最大数字**：确定需要处理多少位
2. **从最低位开始**：个位 → 十位 → 百位 → ...
3. **按当前位排序**：使用稳定的排序算法（通常用计数排序）
4. **重复**直到最高位

## 3. 详细示例

对数组 `[170, 45, 75, 90, 2, 802, 24, 66]` 进行排序：

### 步骤1：找到最大数字
```
最大值 = 802 → 有3位数
```

### 步骤2：按个位排序
```
原始:   170, 45, 75, 90, 2, 802, 24, 66
个位:    0,   5,  5,  0, 2,   2,  4,  6

按个位排序后: [170, 90, 2, 802, 24, 45, 75, 66]
            (个位:0,0,2,2,4,5,5,6)
```

### 步骤3：按十位排序
```
当前:   170, 90, 2, 802, 24, 45, 75, 66
十位:    7,   9, 0,   0, 2,  4,  7,  6

按十位排序后: [2, 802, 24, 45, 66, 170, 75, 90]
            (十位:0,0,2,4,6,7,7,9)
```

### 步骤4：按百位排序
```
当前:   2, 802, 24, 45, 66, 170, 75, 90
百位:   0,   8,  0,  0,  0,   1,  0,  0

按百位排序后: [2, 24, 45, 66, 75, 90, 170, 802]
```

## 4. Java实现

```java
public class RadixSort {
    
    public static void radixSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        System.out.println("原始数组: " + Arrays.toString(arr));
        
        // 步骤1：找到最大值，确定位数
        int max = Arrays.stream(arr).max().getAsInt();
        int maxDigits = (int) Math.log10(max) + 1;
        
        System.out.printf("最大值: %d, 最大位数: %d%n", max, maxDigits);
        
        // 步骤2：从个位开始，逐位排序
        for (int digit = 1; digit <= maxDigits; digit++) {
            countingSortByDigit(arr, digit);
            System.out.printf("按第%d位排序后: %s%n", digit, Arrays.toString(arr));
        }
    }
    
    // 按特定位进行计数排序
    private static void countingSortByDigit(int[] arr, int digit) {
        int n = arr.length;
        int[] output = new int[n];
        int[] count = new int[10]; // 0-9
        
        // 计算当前位的数字
        int exp = (int) Math.pow(10, digit - 1);
        
        // 统计频率
        for (int i = 0; i < n; i++) {
            int digitValue = (arr[i] / exp) % 10;
            count[digitValue]++;
        }
        
        System.out.printf("  计数数组: %s%n", Arrays.toString(count));
        
        // 计算位置（前缀和）
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }
        
        System.out.printf("  位置数组: %s%n", Arrays.toString(count));
        
        // 从后往前构建输出数组（保持稳定性）
        for (int i = n - 1; i >= 0; i--) {
            int digitValue = (arr[i] / exp) % 10;
            output[count[digitValue] - 1] = arr[i];
            count[digitValue]--;
        }
        
        // 拷贝回原数组
        System.arraycopy(output, 0, arr, 0, n);
    }
    
    // 简化版本
    public static void radixSortSimple(int[] arr) {
        if (arr == null || arr.length <= 1) return;
        
        int max = Arrays.stream(arr).max().getAsInt();
        
        // 从个位开始，逐位排序
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countingSortByDigit(arr, exp);
        }
    }
    
    private static void countingSortByDigit(int[] arr, int exp) {
        int n = arr.length;
        int[] output = new int[n];
        int[] count = new int[10];
        
        // 统计频率
        for (int i = 0; i < n; i++) {
            count[(arr[i] / exp) % 10]++;
        }
        
        // 计算位置
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }
        
        // 构建输出数组
        for (int i = n - 1; i >= 0; i--) {
            int digit = (arr[i] / exp) % 10;
            output[count[digit] - 1] = arr[i];
            count[digit]--;
        }
        
        // 拷贝回原数组
        System.arraycopy(output, 0, arr, 0, n);
    }
    
    // 测试代码
    public static void main(String[] args) {
        int[] arr = {170, 45, 75, 90, 2, 802, 24, 66};
        
        System.out.println("=== 基数排序演示 ===");
        radixSort(arr);
        
        System.out.println("\n最终排序结果: " + Arrays.toString(arr));
    }
}
```

## 5. 运行结果示例

```
=== 基数排序演示 ===
原始数组: [170, 45, 75, 90, 2, 802, 24, 66]
最大值: 802, 最大位数: 3

按第1位排序后:
  计数数组: [2, 0, 2, 0, 1, 2, 1, 0, 0, 0]
  位置数组: [2, 2, 4, 4, 5, 7, 8, 8, 8, 8]
  [170, 90, 2, 802, 24, 45, 75, 66]

按第2位排序后:
  计数数组: [2, 0, 1, 0, 1, 0, 1, 2, 0, 1]
  位置数组: [2, 2, 3, 3, 4, 4, 5, 7, 7, 8]
  [2, 802, 24, 45, 66, 170, 75, 90]

按第3位排序后:
  计数数组: [6, 1, 0, 0, 0, 0, 0, 0, 1, 0]
  位置数组: [6, 7, 7, 7, 7, 7, 7, 7, 8, 8]
  [2, 24, 45, 66, 75, 90, 170, 802]

最终排序结果: [2, 24, 45, 66, 75, 90, 170, 802]
```

## 6. 算法特点

**时间复杂度：** O(d × (n + k))
- d：最大位数
- n：数组长度
- k：基数（十进制为10）

**空间复杂度：** O(n + k) - 需要输出数组和计数数组

**优点：**
- 时间复杂度为**线性** O(dn)
- **稳定排序**
- 适合整数、字符串等可以"按位"比较的数据
- 当d较小且n较大时非常高效

**缺点：**
- 需要额外的内存空间
- 只适用于可以按位比较的数据类型
- 对于位数差异大的数据可能不够高效

## 7. 两种实现方式

### 7.1 LSD（最低位优先）
```java
// 我们上面实现的就是LSD
// 从最低位开始排序
// 适合位数固定的数字
```

### 7.2 MSD（最高位优先）
```java
// 从最高位开始排序，递归处理
// 适合字符串排序
// 可能提前结束（如果高位已经能确定顺序）
```

## 8. 适用场景

### 8.1 理想情况
```java
// 固定位数的数字（如身份证号、电话号码）
int[] phones = {13800138000, 13900139000, 13700137000};

// 字符串排序
String[] names = {"Alice", "Bob", "Charlie", "David"};

// 数值范围较大的整数
int[] bigNumbers = {1000000, 2000000, 1500000, 500000};
```

### 8.2 不适用情况
```java
// 浮点数（需要特殊处理）
double[] prices = {19.99, 29.50, 15.75};

// 负数（需要偏移处理）
int[] withNegatives = {5, -3, 2, -1, 4};
```

## 9. 字符串排序示例

基数排序特别适合字符串排序：

```java
public static void radixSortStrings(String[] arr) {
    int maxLength = Arrays.stream(arr).mapToInt(String::length).max().getAsInt();
    
    // 从最后一个字符开始排序
    for (int pos = maxLength - 1; pos >= 0; pos--) {
        countingSortByChar(arr, pos);
    }
}

private static void countingSortByChar(String[] arr, int pos) {
    int n = arr.length;
    String[] output = new String[n];
    int[] count = new int[256]; // ASCII字符集
    
    // 统计频率
    for (String s : arr) {
        int charValue = (pos < s.length()) ? s.charAt(pos) : 0;
        count[charValue]++;
    }
    
    // 计算位置
    for (int i = 1; i < 256; i++) {
        count[i] += count[i - 1];
    }
    
    // 构建输出数组
    for (int i = n - 1; i >= 0; i--) {
        String s = arr[i];
        int charValue = (pos < s.length()) ? s.charAt(pos) : 0;
        output[count[charValue] - 1] = s;
        count[charValue]--;
    }
    
    // 拷贝回原数组
    System.arraycopy(output, 0, arr, 0, n);
}
```

## 10. 关键理解点

1. **按位排序**：像整理扑克牌一样，先按花色，再按数字
2. **稳定性重要**：必须使用稳定排序作为子程序
3. **LSD vs MSD**：LSD简单直观，MSD可能更高效
4. **适用范围**：适合位数不多但数据量大的情况

基数排序是"分而治之"思想的优美体现，通过将复杂问题分解为简单的按位排序，实现了线性的时间复杂度！