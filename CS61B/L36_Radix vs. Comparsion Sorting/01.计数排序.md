好的，我们来详细讲解**计数排序**，这是一种非常高效的非比较排序算法。

## 1. 核心思想

计数排序的基本思想很直观：**统计每个元素出现的次数，然后按顺序重建数组**。

就像整理一堆彩色积木：
- 先数一数每种颜色有多少个
- 然后按颜色顺序把积木摆出来

## 2. 算法步骤

### 步骤1：找出范围
找到数组中的最小值和最大值，确定数据范围。

### 步骤2：统计频率
创建一个计数数组，统计每个值出现的次数。

### 步骤3：计算位置
将计数数组转换为位置数组（前缀和）。

### 步骤4：排序输出
根据位置数组将元素放到正确位置。

## 3. 详细示例

对数组 `[4, 2, 2, 8, 3, 3, 1]` 进行排序：

### 步骤1：找出范围
```
最小值 = 1, 最大值 = 8
范围大小 = 8 - 1 + 1 = 8
```

### 步骤2：统计频率
创建计数数组 `count[8]`（索引0对应值1，索引7对应值8）：
```
值:    1  2  3  4  5  6  7  8
计数: [1, 2, 2, 1, 0, 0, 0, 1]
```

### 步骤3：计算位置（前缀和）
```
原计数: [1, 2, 2, 1, 0, 0, 0, 1]
位置:   [1, 3, 5, 6, 6, 6, 6, 7]
解释：位置数组表示每个值在输出数组中的起始位置
```

### 步骤4：排序输出
从后往前遍历原数组，根据位置数组放置元素：
```
输入: [4, 2, 2, 8, 3, 3, 1]

处理过程：
- 元素1 → 位置0 → 输出[1, _, _, _, _, _, _]
- 元素3 → 位置4 → 输出[1, _, _, 3, _, _, _]  
- 元素3 → 位置3 → 输出[1, _, 3, 3, _, _, _]
- 元素8 → 位置6 → 输出[1, _, 3, 3, _, _, 8]
- 元素2 → 位置1 → 输出[1, 2, 3, 3, _, _, 8]
- 元素2 → 位置0 → 输出[1, 2, 2, 3, 3, _, 8]
- 元素4 → 位置5 → 输出[1, 2, 2, 3, 3, 4, 8]
```

## 4. Java实现

```java
public class CountingSort {
    
    public static void countingSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        System.out.println("原始数组: " + Arrays.toString(arr));
        
        // 步骤1：找出数组的范围
        int max = Arrays.stream(arr).max().getAsInt();
        int min = Arrays.stream(arr).min().getAsInt();
        int range = max - min + 1;
        
        System.out.printf("数值范围: %d ~ %d, 范围大小: %d%n", min, max, range);
        
        // 步骤2：创建计数数组并统计频率
        int[] count = new int[range];
        for (int num : arr) {
            count[num - min]++;
        }
        System.out.println("计数数组: " + Arrays.toString(count));
        
        // 步骤3：将计数数组转换为位置数组（前缀和）
        for (int i = 1; i < range; i++) {
            count[i] += count[i - 1];
        }
        System.out.println("位置数组: " + Arrays.toString(count));
        
        // 步骤4：构建输出数组
        int[] output = new int[arr.length];
        for (int i = arr.length - 1; i >= 0; i--) {
            int num = arr[i];
            int pos = count[num - min] - 1;
            output[pos] = num;
            count[num - min]--;
            
            System.out.printf("放置 %d 到位置 %d: %s%n", 
                            num, pos, Arrays.toString(output));
        }
        
        // 步骤5：将排序结果拷贝回原数组
        System.arraycopy(output, 0, arr, 0, arr.length);
        
        System.out.println("最终结果: " + Arrays.toString(arr));
    }
    
    // 简化版本
    public static void countingSortSimple(int[] arr) {
        if (arr == null || arr.length <= 1) return;
        
        // 找出范围
        int max = Arrays.stream(arr).max().getAsInt();
        int min = Arrays.stream(arr).min().getAsInt();
        int range = max - min + 1;
        
        // 计数
        int[] count = new int[range];
        for (int num : arr) {
            count[num - min]++;
        }
        
        // 重建数组
        int index = 0;
        for (int i = 0; i < range; i++) {
            while (count[i] > 0) {
                arr[index++] = i + min;
                count[i]--;
            }
        }
    }
    
    // 测试代码
    public static void main(String[] args) {
        int[] arr = {4, 2, 2, 8, 3, 3, 1};
        
        System.out.println("=== 计数排序演示 ===");
        countingSort(arr);
    }
}
```

## 5. 运行结果示例

```
=== 计数排序演示 ===
原始数组: [4, 2, 2, 8, 3, 3, 1]
数值范围: 1 ~ 8, 范围大小: 8
计数数组: [1, 2, 2, 1, 0, 0, 0, 1]
位置数组: [1, 3, 5, 6, 6, 6, 6, 7]
放置 1 到位置 0: [1, 0, 0, 0, 0, 0, 0]
放置 3 到位置 4: [1, 0, 0, 0, 3, 0, 0]
放置 3 到位置 3: [1, 0, 0, 3, 3, 0, 0]
放置 8 到位置 6: [1, 0, 0, 3, 3, 0, 8]
放置 2 到位置 1: [1, 2, 0, 3, 3, 0, 8]
放置 2 到位置 0: [1, 2, 2, 3, 3, 0, 8]
放置 4 到位置 5: [1, 2, 2, 3, 3, 4, 8]
最终结果: [1, 2, 2, 3, 3, 4, 8]
```

## 6. 算法特点

**时间复杂度：** O(n + k)
- n：数组长度
- k：数据范围大小（max - min + 1）

**空间复杂度：** O(k) - 需要计数数组

**优点：**
- 时间复杂度为**线性** O(n + k)
- **稳定排序**（如果使用位置数组方法）
- 简单直观

**缺点：**
- 只适用于**整数排序**
- 当数据范围k很大时，需要大量内存
- 不适用于浮点数或字符串

## 7. 适用场景

### 7.1 理想情况
```java
// 小范围整数排序
int[] ages = {25, 23, 24, 25, 23, 26, 24}; // 范围很小
int[] grades = {85, 90, 92, 85, 88, 90};    // 分数范围固定
```

### 7.2 不适用情况
```java
// 范围过大
int[] bigNumbers = {1, 1000000, 500000}; // 范围太大，浪费空间

// 非整数数据
double[] prices = {19.99, 29.50, 15.75}; // 不适用
String[] names = {"Alice", "Bob", "Charlie"}; // 不适用
```

## 8. 与其他排序算法的对比

| 特性 | 计数排序 | 快速排序 | 归并排序 |
|------|----------|----------|----------|
| 时间复杂度 | O(n + k) | O(n log n) | O(n log n) |
| 稳定性 | 稳定 | 不稳定 | 稳定 |
| 适用数据类型 | 整数 | 任何可比较类型 | 任何可比较类型 |
| 额外空间 | O(k) | O(log n) | O(n) |

## 9. 关键理解点

1. **非比较排序**：不通过元素间的比较来决定顺序
2. **范围重要性**：性能取决于数据范围k，而不是数据量n
3. **稳定性**：从后往前遍历原数组可以保持稳定性
4. **空间换时间**：用额外的计数数组换取线性时间复杂度

## 10. 实际应用

### 10.1 统计成绩分布
```java
// 统计0-100分的成绩分布并排序
int[] scores = {85, 92, 78, 85, 90, 92, 78, 85};
countingSort(scores); // 非常高效！
```

### 10.2 字母频率统计
```java
// 统计小写字母频率（范围a-z）
char[] letters = {'b', 'a', 'c', 'b', 'a', 'a'};
int[] count = new int[26]; // 26个字母
for (char c : letters) {
    count[c - 'a']++;
}
```

计数排序在适合的场景下性能极其出色，是"用空间换时间"策略的经典体现！