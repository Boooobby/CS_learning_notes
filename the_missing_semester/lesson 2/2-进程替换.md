在 Linux Shell 中，`<()` 是一种称为 **进程替换（Process Substitution）** 的特殊语法，主要用于将 **命令的输出** 临时转换为 **文件描述符**，使其可以被其他命令作为文件参数读取。它通常用于需要文件输入但数据来自命令输出的场景。

---

## **1. 基本语法**
- **输入型进程替换**（将命令输出作为文件读取）：
  ```bash
  command1 <(command2)
  ```
  相当于：
  ```bash
  command2 > temp_file
  command1 temp_file
  rm temp_file
  ```
  但 `<()` **不会创建真实文件**，而是通过管道和文件描述符传递数据。

- **输出型进程替换**（较少用）：
  ```bash
  command1 >(command2)
  ```
  将 `command1` 的输出传递给 `command2` 处理。

---

## **2. 核心用途**
### **(1) 替代临时文件**
某些命令（如 `diff`、`paste`）需要文件参数，但数据来自其他命令时，可用 `<()` 避免创建临时文件：
```bash
diff <(ls dir1) <(ls dir2)  # 比较两个目录的文件列表
```

### **(2) 多命令数据合并**
```bash
paste <(cut -f1 file1.txt) <(cut -f2 file2.txt)  # 合并两文件的指定列
```

### **(3) 动态生成输入**
```bash
grep "pattern" <(curl -s http://example.com/data.txt)  # 直接处理网络数据
```

---

## **3. 实际示例**
### **示例 1：比较两个命令的输出**
```bash
diff <(sort file1.txt) <(sort file2.txt)  # 对文件排序后比较差异
```

### **示例 2：将命令输出作为输入文件**
```bash
# 统计当前目录下各文件的行数（需文件名和行数）
wc -l <(find . -type f -name "*.sh")
```
输出类似：
```
5 /dev/fd/63
```
（`/dev/fd/63` 是系统自动分配的文件描述符路径）

### **示例 3：多进程协作**
```bash
# 将 tar 压缩的内容直接通过 gpg 加密
tar -czf - /data | gpg -c > backup.tar.gz.gpg
# 等效于：
tar -czf >(gpg -c > backup.tar.gz.gpg) /data
```

---

## **4. 实现原理**
1. Shell 会创建一个 **匿名管道（FIFO）** 或 **/dev/fd/* 文件描述符**。
2. 将 `<(command)` 替换为临时文件路径（如 `/dev/fd/63`）。
3. 目标命令读取该文件时，实际读取的是 `command` 的输出。

---

## **5. 注意事项**
- **仅限支持文件参数的命令**：如 `diff`、`paste`、`cat`、`wc` 等。
- **不可用于所有场景**：例如 `vim <(echo "text")` 会失败，因为 `vim` 需要真实文件。
- **Bash/Zsh 支持**：不是所有 Shell 都支持进程替换（如 `dash` 不支持）。
- **与管道 `|` 的区别**：
  - 管道 `|` 只能传递 **标准输出** 给下一个命令。
  - `<()` 生成一个 **临时文件路径**，适合需要文件参数的场景。

---

## **6. 扩展用法**
### **(1) 输出型进程替换 `>()`**
将命令的输出重定向到另一个命令：
```bash
# 将 tar 的输出同时传递给 gzip 和 tee
tar -cf >(gzip > backup.tar.gz) >(tee backup.tar | sha256sum > checksum.txt) /data
```

### **(2) 嵌套使用**
```bash
diff <(sort <(grep "A" file1)) <(sort <(grep "B" file2))
```

---

## **7. 常见问题**
### **Q：为什么 `echo <(ls)` 输出 `/dev/fd/63`？**
- `<(ls)` 会被替换为一个文件描述符路径（如 `/dev/fd/63`），而 `echo` 直接打印该路径而非内容。  
- 正确用法是让命令读取该文件：
  ```bash
  cat <(ls)      # 显示 ls 的输出
  ```

### **Q：如何检查 Shell 是否支持进程替换？**
```bash
# 在 Bash 中测试
if [[ -e "/dev/fd/0" ]]; then
    echo "Process substitution is supported."
fi
```

---

## **总结**
| 场景                     | 示例                          | 说明                          |
|--------------------------|-------------------------------|-------------------------------|
| 避免临时文件             | `diff <(cmd1) <(cmd2)`       | 动态生成输入文件              |
| 多命令数据合并           | `paste <(cut -f1 f1) <(cut -f2 f2)` | 合并两命令的输出             |
| 动态处理网络/流数据      | `grep "x" <(curl URL)`       | 直接处理命令输出的数据        |

`<()` 是 Shell 中强大的高级特性，能优雅地解决 **“命令输出作为文件输入”** 的需求！