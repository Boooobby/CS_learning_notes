# Python 中将函数作为参数传递

在 Python 中，函数是一等公民（first-class citizen），这意味着函数可以像其他数据类型一样被传递和使用。将函数作为参数传递是 Python 中非常强大且常用的特性。

## 基本概念

### 1. 函数作为对象
在 Python 中，函数也是对象，可以：
- 赋值给变量
- 存储在数据结构中
- 作为参数传递给其他函数
- 作为其他函数的返回值

### 2. 为什么需要函数作为参数？
- 实现高阶函数（higher-order functions）
- 实现回调机制（callback）
- 增加代码的灵活性和复用性
- 支持函数式编程范式

## 基本用法

### 1. 简单示例
```python
def greet(name):
    return f"Hello, {name}!"

def call_func(func, arg):
    return func(arg)

result = call_func(greet, "Alice")
print(result)  # 输出: Hello, Alice!
```

### 2. 结合内置函数使用
```python
# 使用内置函数作为参数
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, numbers))
print(squared)  # 输出: [1, 4, 9, 16, 25]
```

## 常见应用场景

### 1. 回调函数
```python
def process_data(data, callback):
    # 处理数据...
    result = data * 2
    # 调用回调函数
    callback(result)

def print_result(res):
    print(f"结果是: {res}")

process_data(10, print_result)  # 输出: 结果是: 20
```

### 2. 策略模式
```python
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def calculate(a, b, operation):
    return operation(a, b)

print(calculate(5, 3, add))      # 输出: 8
print(calculate(5, 3, subtract)) # 输出: 2
```

### 3. 装饰器基础
```python
def my_decorator(func):
    def wrapper():
        print("函数执行前")
        func()
        print("函数执行后")
    return wrapper

def say_hello():
    print("Hello!")

# 将函数作为参数传递给装饰器
decorated_func = my_decorator(say_hello)
decorated_func()
```

## 高级用法

### 1. 传递带有参数的函数
```python
def power(base, exp):
    return base ** exp

def apply_operation(func, *args):
    return func(*args)

print(apply_operation(power, 2, 3))  # 输出: 8
```

### 2. 类方法作为参数
```python
class Calculator:
    def add(self, a, b):
        return a + b

calc = Calculator()
print(apply_operation(calc.add, 2, 3))  # 输出: 5
```

### 3. 结合lambda函数
```python
numbers = [1, 2, 3, 4, 5]
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # 输出: [2, 4]
```

## 实际应用示例

### 1. 排序自定义
```python
students = [
    {"name": "Alice", "grade": 90},
    {"name": "Bob", "grade": 85},
    {"name": "Charlie", "grade": 92}
]

# 按成绩排序
sorted_students = sorted(students, key=lambda x: x["grade"], reverse=True)
print(sorted_students)
```

### 2. 事件处理系统
```python
class EventHandler:
    def __init__(self):
        self.handlers = []
    
    def register_handler(self, handler):
        self.handlers.append(handler)
    
    def trigger_event(self, data):
        for handler in self.handlers:
            handler(data)

def log_event(data):
    print(f"事件日志: {data}")

handler = EventHandler()
handler.register_handler(log_event)
handler.trigger_event("系统启动")  # 输出: 事件日志: 系统启动
```

## 注意事项

1. **不要加括号**：传递函数时使用函数名，不要加括号（加了就是调用函数了）
   ```python
   # 正确
   call_func(greet, "Alice")
   
   # 错误
   call_func(greet("Alice"), "Alice")  # 这里会先调用greet函数
   ```

2. **函数签名**：确保传递的函数接受正确的参数数量和类型

3. **可读性**：当逻辑复杂时，考虑定义命名函数而不是使用lambda

4. **性能考虑**：频繁的函数调用会有性能开销，在性能关键代码中需注意

## 总结

Python中函数作为参数传递的特性使得代码更加灵活和强大，它是实现以下模式的基础：
- 回调机制
- 策略模式
- 装饰器
- 函数式编程
- 事件驱动编程

掌握这一概念可以显著提高你的Python编程能力，写出更加模块化和可复用的代码。