你的问题涉及 Python 中一个非常重要的概念——**默认参数的可变对象陷阱**。让我们详细解释为什么会出现 `[1, 1]` 而不是两个 `[1]`。

## 根本原因

**默认参数在函数定义时（def 语句执行时）就被评估并绑定，而不是在每次函数调用时重新创建**。对于可变对象（如列表、字典等），这意味着：

1. 函数定义时：`a=[]` 创建一个空列表对象
2. 这个列表对象会成为函数对象的一部分（存储在 `func.__defaults__` 中）
3. **每次调用函数时，如果没有显式提供 a 参数，就会使用这个同一个列表对象**

## 执行过程分解

```python
def func(a=[]):    # 步骤1：Python 在这里创建空列表对象，绑定到默认参数a
    a.append(1)    # 步骤3：修改这个列表
    print(a)

func()  # 步骤2：第一次调用，使用默认列表
        # 输出 [1]
        # 现在默认列表内容变为 [1]

func()  # 步骤4：第二次调用，仍然使用同一个默认列表
        # 输出 [1, 1]
```

## 关键证据

你可以查看函数的默认值存储位置：

```python
print(func.__defaults__)  # 输出 ([1, 1],) 证明列表被保留了
```

## 为什么函数结束后 a 没有消失？

1. 这个列表不是函数的局部变量，而是**函数对象的属性**
2. 只要函数对象存在，这个默认列表就会一直存在
3. 每次调用只是临时获得对这个列表的引用

## 正确的做法

如果需要每次调用都获得新列表，应该这样做：

```python
def func(a=None):
    if a is None:  # 显式检查None
        a = []     # 每次调用创建新列表
    a.append(1)
    print(a)

func()  # [1]
func()  # [1] 现在是独立的列表
```

## 设计原理

Python 这样设计是因为：
1. 默认参数评估一次比每次调用都评估更高效
2. 对于不可变对象（数字、字符串、元组等）这种设计没有问题
3. 只有对可变对象才会出现这种"意外"行为

这个特性虽然初看起来违反直觉，但理解后可以主动利用它来实现某些模式（比如缓存），但更多时候需要注意避免这种陷阱。