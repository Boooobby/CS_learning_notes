Python 和 C++ 的递归实现有显著差异，主要体现在 **语言特性**、**性能优化** 和 **递归深度限制** 上。Python 有一些独特的技巧（如装饰器缓存、生成器递归等），而 C++ 更依赖编译优化（如尾递归优化）。以下是详细对比：

---

### 一、核心差异对比
| 特性                | Python                            | C++                              |
|---------------------|-----------------------------------|----------------------------------|
| **递归深度限制**     | 默认约 1000（`sys.setrecursionlimit` 可修改） | 由栈大小决定，通常远大于 Python（但可能栈溢出） |
| **尾递归优化 (TCO)** | 不支持（需手动转循环）             | 编译器可能优化（如 `g++ -O2`）     |
| **内存模型**         | 堆分配对象，无栈对象               | 默认栈分配局部变量，可能更快       |
| **递归工具**         | 装饰器缓存、生成器、动态类型       | 模板元编程、constexpr 编译期计算  |

---

### 二、Python 独有的递归技巧
#### 1. **使用 `@functools.lru_cache` 自动缓存**
避免重复计算，显著提升性能（如斐波那契数列）：
```python
from functools import lru_cache

@lru_cache(maxsize=None)
def fib(n):
    if n < 2:
        return n
    return fib(n-1) + fib(n-2)
```

#### 2. **生成器递归（惰性求值）**
生成器递归不消耗栈空间，适合处理无限序列：
```python
def infinite_sequence():
    n = 0
    while True:
        yield n
        n += 1

# 或递归生成器
def traverse_tree(node):
    if node:
        yield from traverse_tree(node.left)
        yield node.value
        yield from traverse_tree(node.right)
```

#### 3. **动态参数解包**
Python 的 `*args` 和 `**kwargs` 灵活处理递归参数：
```python
def recursive_sum(*args):
    if not args:
        return 0
    return args[0] + recursive_sum(*args[1:])
```

#### 4. **利用异常控制递归深度**
Python 无尾递归优化，但可通过异常模拟：
```python
import sys

class RecursionLimitExceeded(Exception):
    pass

def safe_recursion(func):
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except RecursionError:
            raise RecursionLimitExceeded
    return wrapper
```

---

### 三、C++ 的递归优化策略
#### 1. **尾递归优化（需编译器支持）**
```cpp
int factorial(int n, int acc = 1) {
    if (n == 0) return acc;
    return factorial(n - 1, acc * n);  // 可能被优化为循环
}
```
（需开启 `-O2` 编译选项）

#### 2. **模板元编程（编译期递归）**
```cpp
template<int N>
struct Factorial {
    static constexpr int value = N * Factorial<N-1>::value;
};

template<>
struct Factorial<0> {
    static constexpr int value = 1;
};

// 编译期计算 Factorial<5>::value
```

#### 3. **手动栈模拟**
避免递归深度限制：
```cpp
#include <stack>
int factorial(int n) {
    std::stack<int> s;
    s.push(1);
    while (n > 1) {
        s.push(s.top() * n--);
    }
    return s.top();
}
```

---

### 四、何时选择递归？
| 场景               | Python 适用性 | C++ 适用性 |
|--------------------|--------------|------------|
| 深度递归（>1000层） | ❌ 需改循环    | ✅ 栈足够大  |
| 数学定义清晰（如分治） | ✅ 代码简洁   | ✅ 性能更高  |
| 需要缓存中间结果     | ✅ `lru_cache` | ❌ 需手动实现 |
| 编译期计算          | ❌ 不支持      | ✅ 模板元编程 |

---

### 五、总结建议
1. **Python 递归技巧**：
   - 优先用 `lru_cache` 缓存
   - 深递归改用生成器或循环
   - 动态参数灵活处理树/图结构

2. **C++ 递归技巧**：
   - 开启编译器优化（`-O2`）
   - 尾递归写法 + 模板元编程
   - 栈溢出风险高时手动转循环

Python 的递归更侧重 **代码简洁** 和 **动态特性**，而 C++ 更注重 **性能控制** 和 **编译期优化**。