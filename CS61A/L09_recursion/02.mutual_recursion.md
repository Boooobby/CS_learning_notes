# 相互递归（Mutual Recursion）详解

相互递归是指两个或多个函数相互调用形成的递归关系，是递归的一种特殊形式。

## 基本概念

相互递归的特点是：
- 函数A调用函数B
- 函数B又调用函数A
- 形成交替递归调用链

## 基本示例

### 判断奇偶数

```python
def is_even(n):
    if n == 0:
        return True
    return is_odd(n - 1)

def is_odd(n):
    if n == 0:
        return False
    return is_even(n - 1)

print(is_even(4))  # True
print(is_odd(5))   # True
```

### 语法解析示例

```python
def parse_expression(tokens):
    term = parse_term(tokens)
    # 处理加减法
    while tokens and tokens[0] in ('+', '-'):
        op = tokens.pop(0)
        term2 = parse_term(tokens)
        term = (op, term, term2)
    return term

def parse_term(tokens):
    factor = parse_factor(tokens)
    # 处理乘除法
    while tokens and tokens[0] in ('*', '/'):
        op = tokens.pop(0)
        factor2 = parse_factor(tokens)
        factor = (op, factor, factor2)
    return factor

def parse_factor(tokens):
    # 处理数字和括号表达式
    token = tokens.pop(0)
    if token == '(':
        expr = parse_expression(tokens)
        assert tokens.pop(0) == ')'
        return expr
    return int(token)
```

## 相互递归的特点

1. **调用关系复杂**：比直接递归更难理解和调试
2. **终止条件重要**：必须确保至少一条路径能终止
3. **性能考虑**：可能产生较深的调用栈

## Python中的实现技巧

### 1. 前向声明

```python
def function_a(n):  # 需要先声明
    pass

def function_b(n):
    if n == 0: return 0
    return function_a(n - 1)

def function_a(n):  # 完整定义
    if n == 0: return 1
    return function_b(n - 1)
```

### 2. 使用闭包

```python
def make_mutual_recursive():
    def a(n):
        if n == 0: return 1
        return b(n - 1)
    
    def b(n):
        if n == 0: return 0
        return a(n - 1)
    
    return a, b

even, odd = make_mutual_recursive()
```

### 3. 类方法相互调用

```python
class MutualRecursion:
    def method_a(self, n):
        if n == 0: return 1
        return self.method_b(n - 1)
    
    def method_b(self, n):
        if n == 0: return 0
        return self.method_a(n - 1)
```

## 应用场景

1. **语法分析**：解析嵌套语法结构
2. **状态机实现**：状态之间的相互转换
3. **数学定义**：相互定义的数学函数
4. **游戏AI**：对手策略的相互响应

## 注意事项

1. **栈深度限制**：Python默认递归深度约1000层
2. **性能优化**：可改用循环或记忆化(memoization)
3. **调试困难**：调用栈较复杂，建议添加日志

相互递归虽然不如直接递归常见，但在处理某些特定问题时非常有用，能够更自然地表达相互定义的逻辑关系。