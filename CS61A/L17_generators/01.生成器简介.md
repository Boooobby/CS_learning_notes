# Python中的生成器(Generator)

生成器是Python中一种特殊的迭代器，它允许你按需生成值，而不是一次性生成所有值并存储在内存中。这使得生成器非常适合处理大量数据或无限序列。

## 基本概念

生成器与普通函数的区别在于：
- 普通函数使用`return`返回结果
- 生成器使用`yield`产生值，可以暂停和恢复执行

## 创建生成器

### 方法1：生成器函数

使用`yield`关键字定义生成器函数：

```python
def count_up_to(max):
    count = 1
    while count <= max:
        yield count
        count += 1

# 使用生成器
counter = count_up_to(5)
for num in counter:
    print(num)  # 输出1, 2, 3, 4, 5
```

### 方法2：生成器表达式

类似于列表推导式，但使用圆括号：

```python
gen = (x**2 for x in range(10))
print(next(gen))  # 输出0
print(next(gen))  # 输出1
```

## 生成器的特点

1. **惰性求值**：只在需要时生成值，节省内存
2. **状态保持**：每次`yield`后函数状态被保存，下次从该状态继续
3. **一次性使用**：生成器只能迭代一次，要再次使用需要重新创建

## 常用方法

- `next()`: 获取下一个值
- `.send()`: 向生成器发送值
- `.close()`: 关闭生成器
- `.throw()`: 在生成器中引发异常

## 实际应用示例

### 1. 处理大文件

```python
def read_large_file(file_path):
    with open(file_path) as file:
        for line in file:
            yield line.strip()

# 逐行处理大文件而不加载到内存
for line in read_large_file('huge_file.txt'):
    process(line)
```

### 2. 无限序列

```python
def infinite_sequence():
    num = 0
    while True:
        yield num
        num += 1

gen = infinite_sequence()
print(next(gen))  # 0
print(next(gen))  # 1
# 可以无限继续
```

### 3. 协程实现

```python
def coroutine():
    while True:
        received = yield
        print(f"Received: {received}")

c = coroutine()
next(c)  # 启动生成器
c.send("Hello")  # 输出"Received: Hello"
```

## 性能优势

生成器的主要优势在于内存效率，因为它不需要一次性存储所有值。对于大数据处理特别有用。

生成器是Python中强大而高效的工具，掌握它们可以显著提升你的Python编程能力。