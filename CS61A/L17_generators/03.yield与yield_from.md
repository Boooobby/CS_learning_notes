# Python中的yield和yield from语句详解

## 1. yield语句

### 基本概念
`yield`是Python中用于定义生成器函数的关键字。当函数中包含`yield`语句时，这个函数就变成了一个生成器函数，调用时不会立即执行，而是返回一个生成器对象。

### 工作原理
1. 调用生成器函数时，返回一个生成器对象，代码不会立即执行
2. 第一次调用`next()`时，函数开始执行，直到遇到第一个`yield`
3. `yield`会暂停函数执行，返回yield后面的值
4. 再次调用`next()`时，函数从上次暂停的位置继续执行
5. 当函数执行完毕或遇到return时，抛出StopIteration异常

### 基本用法
```python
def simple_generator():
    yield 1
    yield 2
    yield 3

gen = simple_generator()
print(next(gen))  # 输出1
print(next(gen))  # 输出2
print(next(gen))  # 输出3
# print(next(gen))  # 抛出StopIteration
```

### 生成器状态保持
生成器会记住上次执行的位置和所有局部变量的值：

```python
def counter(start=0):
    count = start
    while True:
        yield count
        count += 1

c = counter(5)
print(next(c))  # 5
print(next(c))  # 6
```

### 与return的区别
- `return`终止函数执行并返回值
- `yield`暂停函数执行并返回值，下次调用从暂停处继续

## 2. yield from语句

### 基本概念
`yield from`是Python 3.3引入的语法，用于简化生成器中嵌套其他可迭代对象的代码。它可以委托另一个生成器或可迭代对象来完成部分或全部yield操作。

### 基本用法
```python
def generator1():
    yield from [1, 2, 3]
    yield from (x**2 for x in range(3))

for val in generator1():
    print(val)  # 输出1,2,3,0,1,4
```

### 等价转换
`yield from`可以看作是以下代码的语法糖：

```python
# yield from iterable 等价于
for item in iterable:
    yield item
```

### 高级功能
1. **双向通信**：`yield from`建立了调用方和子生成器之间的双向通道
2. **异常处理**：子生成器的异常会直接传递给调用方
3. **返回值**：子生成器的返回值可以通过`yield from`表达式获取

### 双向通信示例
```python
def subgenerator():
    while True:
        received = yield
        print(f"Received: {received}")

def delegator():
    yield from subgenerator()

d = delegator()
next(d)  # 启动生成器
d.send("Hello")  # 输出"Received: Hello"
```

### 返回值处理
```python
def subgen():
    yield 1
    yield 2
    return "Done"

def delegator():
    result = yield from subgen()
    yield f"Subgen returned: {result}"

for val in delegator():
    print(val)
# 输出:
# 1
# 2
# Subgen returned: Done
```

## 3. yield和yield from的比较

| 特性                | yield                          | yield from                     |
|---------------------|--------------------------------|--------------------------------|
| 引入版本            | Python 2.2                     | Python 3.3                     |
| 功能                | 生成单个值                     | 委托给另一个生成器或可迭代对象 |
| 代码复杂度          | 简单                           | 简化嵌套生成器的代码           |
| 双向通信            | 需要手动实现                   | 自动支持                       |
| 异常处理            | 需要手动处理                   | 自动传递异常                   |
| 返回值获取          | 不支持                         | 支持获取子生成器返回值         |
| 主要用途            | 创建简单生成器                 | 组合多个生成器                 |

## 4. 实际应用场景

### yield的典型应用
1. **惰性求值**：处理大数据集时节省内存
```python
def read_large_file(file):
    while True:
        line = file.readline()
        if not line:
            break
        yield line
```

2. **无限序列**：表示无限或很大的序列
```python
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b
```

3. **状态保持**：需要保持状态的函数
```python
def running_avg():
    total = 0
    count = 0
    while True:
        num = yield total/count if count else 0
        total += num
        count += 1
```

### yield from的典型应用
1. **生成器组合**：合并多个生成器
```python
def chain(*iterables):
    for it in iterables:
        yield from it
```

2. **协程委派**：实现协程间的调用
```python
def worker():
    while True:
        task = yield
        print(f"Processing {task}")

def manager():
    yield from worker()

m = manager()
next(m)
m.send("Task 1")
```

3. **复杂管道**：构建数据处理管道
```python
def process_data(data):
    yield from preprocess(data)
    yield from analyze(data)
    yield from report(data)
```

## 5. 性能考虑

- `yield from`通常比手动迭代并yield每个元素更高效
- 生成器比列表等容器类型更节省内存，特别是处理大数据时
- 生成器适合流式处理，不适合需要随机访问的场景

## 6. 注意事项

1. 生成器是一次性的，迭代完后需要重新创建
2. `yield from`会完全委派控制权，直到子生成器结束
3. 生成器函数可以有return语句，返回值可以通过StopIteration.value获取
4. 在try/finally块中使用yield时要注意清理逻辑

## 总结

`yield`和`yield from`是Python生成器编程的核心：
- `yield`用于创建基本的生成器，实现惰性求值和状态保持
- `yield from`用于生成器组合和委派，简化代码并支持双向通信
- 两者结合可以构建高效、清晰的数据处理管道和协程系统
- 理解它们的区别和适用场景有助于编写更优雅、高效的Python代码