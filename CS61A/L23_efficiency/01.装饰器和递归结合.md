# Python中的装饰器与递归结合使用

装饰器和递归是Python中两个强大的特性，当它们结合使用时可以创造出非常有趣和实用的模式。下面我将详细介绍这种结合使用的情况。

## 1. 基本概念回顾

### 装饰器
装饰器是一种修改或增强函数行为的方式，而不需要改变函数本身的代码。它本质上是一个接受函数作为参数并返回新函数的高阶函数。

```python
def decorator(func):
    def wrapper(*args, **kwargs):
        print("Before function call")
        result = func(*args, **kwargs)
        print("After function call")
        return result
    return wrapper

@decorator
def say_hello():
    print("Hello!")
```

### 递归
递归是指函数直接或间接调用自身的过程。递归通常用于解决可以分解为相同问题的子问题的问题。

```python
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n-1)
```

## 2. 装饰器与递归的结合使用

### 2.1 跟踪递归调用

装饰器可以用来跟踪递归函数的调用情况，这在调试递归算法时非常有用。

```python
def trace_recursion(func):
    def wrapper(*args, **kwargs):
        # 增加缩进级别
        wrapper.depth += 1
        # 打印调用信息
        print("  " * (wrapper.depth-1), f"--> {func.__name__}({args[0]})")
        result = func(*args, **kwargs)
        # 打印返回信息
        print("  " * (wrapper.depth-1), f"<-- {func.__name__}({args[0]}) = {result}")
        # 减少缩进级别
        wrapper.depth -= 1
        return result
    wrapper.depth = 0
    return wrapper

@trace_recursion
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n-1)

print(factorial(4))
```

输出：
```
--> factorial(4)
  --> factorial(3)
    --> factorial(2)
      --> factorial(1)
        --> factorial(0)
        <-- factorial(0) = 1
      <-- factorial(1) = 1
    <-- factorial(2) = 2
  <-- factorial(3) = 6
<-- factorial(4) = 24
24
```

### 2.2 记忆化装饰器（Memoization）

记忆化是一种优化技术，可以存储函数调用的结果以避免重复计算。这对于递归函数特别有用。

```python
def memoize(func):
    cache = {}
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrapper

@memoize
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(50))  # 没有记忆化的话，这个计算会非常慢
```

### 2.3 限制递归深度

为了防止无限递归或过深的递归调用，我们可以使用装饰器来限制递归深度。

```python
def limit_recursion(max_depth):
    def decorator(func):
        def wrapper(*args, **kwargs):
            wrapper.depth += 1
            if wrapper.depth > max_depth:
                raise RecursionError(f"Maximum recursion depth {max_depth} exceeded")
            try:
                return func(*args, **kwargs)
            finally:
                wrapper.depth -= 1
        wrapper.depth = 0
        return wrapper
    return decorator

@limit_recursion(10)
def recursive_func(n):
    if n == 0:
        return 0
    return recursive_func(n-1) + 1

try:
    print(recursive_func(15))
except RecursionError as e:
    print(e)
```

### 2.4 性能分析装饰器

我们可以使用装饰器来分析递归函数的性能，统计调用次数和执行时间。

```python
import time

def profile_recursion(func):
    def wrapper(*args, **kwargs):
        wrapper.call_count += 1
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        wrapper.total_time += end_time - start_time
        return result
    
    wrapper.call_count = 0
    wrapper.total_time = 0
    return wrapper

@profile_recursion
def fib(n):
    if n < 2:
        return n
    return fib(n-1) + fib(n-2)

result = fib(10)
print(f"Result: {result}")
print(f"Total calls: {fib.call_count}")
print(f"Total time: {fib.total_time:.6f} seconds")
```

## 3. 注意事项

1. **递归深度限制**：Python默认有递归深度限制（通常约1000），可以通过`sys.setrecursionlimit()`修改，但不建议设置过大。

2. **装饰器顺序**：当使用多个装饰器时，顺序很重要。最上面的装饰器会最先执行其包装逻辑。

3. **函数属性**：装饰器可能会覆盖原始函数的属性，可以使用`functools.wraps`来保留原始函数的元数据。

4. **记忆化的副作用**：记忆化会占用内存存储结果，对于输入范围很大的函数要小心使用。

## 4. 总结

装饰器和递归的结合使用可以为递归函数添加各种有用的功能，如调试跟踪、性能优化、安全性检查等。这种组合展示了Python的灵活性和强大功能，使得我们能够在不修改原始递归函数代码的情况下，增强其行为或添加新特性。

在实际应用中，记忆化装饰器可能是最有价值的，因为它可以显著提高递归函数的性能，特别是对于那些具有重叠子问题的递归算法，如斐波那契数列、动态规划问题等。