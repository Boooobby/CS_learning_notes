# Python 中函数作为返回值

在 Python 中，函数不仅可以作为参数传递，还可以作为其他函数的返回值。这种能力是函数作为"一等公民"的重要体现，也是实现许多高级编程模式的基础。

## 基本概念

### 1. 什么是函数作为返回值？
当一个函数返回另一个函数（而不是常规的数据值）时，就是函数作为返回值的用法。

### 2. 为什么需要这种特性？
- 创建函数工厂（动态生成函数）
- 实现闭包（closure）
- 构建装饰器（decorator）
- 实现策略模式等设计模式

## 基本用法

### 1. 简单示例
```python
def create_greeter(greeting):
    def greeter(name):
        return f"{greeting}, {name}!"
    return greeter  # 返回内部定义的函数

hello_greeter = create_greeter("Hello")
print(hello_greeter("Alice"))  # 输出: Hello, Alice!

hi_greeter = create_greeter("Hi")
print(hi_greeter("Bob"))  # 输出: Hi, Bob!
```

### 2. 带参数的函数工厂
```python
def power_factory(exponent):
    def power(base):
        return base ** exponent
    return power

square = power_factory(2)
cube = power_factory(3)

print(square(4))  # 输出: 16
print(cube(4))    # 输出: 64
```

## 高级特性：闭包（Closure）

当内部函数引用外部函数的变量时，会形成闭包：

```python
def counter(start=0):
    count = start
    
    def increment():
        nonlocal count  # 声明使用外部变量
        count += 1
        return count
    
    return increment

c1 = counter(10)
print(c1())  # 输出: 11
print(c1())  # 输出: 12

c2 = counter()  # 新的计数器，从0开始
print(c2())     # 输出: 1
```

闭包的特点：
1. 内部函数记住了创建时的环境
2. 每次调用外部函数会创建新的闭包
3. 闭包内的变量是私有的，外部无法直接访问

## 实际应用场景

### 1. 装饰器（Decorators）
装饰器本质上就是返回函数的函数：

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("函数执行前")
        result = func(*args, **kwargs)
        print("函数执行后")
        return result
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
# 输出:
# 函数执行前
# Hello!
# 函数执行后
```

### 2. 函数记忆化（Memoization）
缓存函数结果以提高性能：

```python
def memoize(func):
    cache = {}
    
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    
    return wrapper

@memoize
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(50))  # 快速计算出结果
```

### 3. 配置化函数生成
根据配置动态生成不同行为的函数：

```python
def create_processor(config):
    if config["sensitive"]:
        def processor(text):
            return text.upper()
    else:
        def processor(text):
            return text.lower()
    
    if config["trim"]:
        old_processor = processor
        def processor(text):
            return old_processor(text).strip()
    
    return processor

config1 = {"sensitive": True, "trim": False}
shout = create_processor(config1)
print(shout(" hello "))  # 输出: " HELLO "

config2 = {"sensitive": False, "trim": True}
whisper = create_processor(config2)
print(whisper(" HELLO "))  # 输出: "hello"
```

## 注意事项

1. **变量作用域**：注意使用 `nonlocal` 关键字修改外部变量
2. **内存消耗**：每个闭包会保持其环境的引用
3. **调试复杂性**：嵌套函数可能使调试更困难
4. **性能考量**：函数调用有一定开销

## 与lambda表达式的结合

```python
def create_operator(op):
    if op == '+':
        return lambda a, b: a + b
    elif op == '*':
        return lambda a, b: a * b
    else:
        return lambda a, b: a - b

adder = create_operator('+')
print(adder(2, 3))  # 输出: 5
```

## 总结

函数作为返回值的特性使Python能够：
- 创建灵活的函数工厂
- 实现闭包和装饰器
- 构建高度可配置的代码
- 支持函数式编程范式

这种能力是Python强大表现力的重要组成部分，掌握它可以显著提高代码的抽象能力和复用性。