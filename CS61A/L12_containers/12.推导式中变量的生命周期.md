在 Python 中，列表推导式（List Comprehension）中的变量的生命周期遵循以下规则：

### 1. **列表推导式中的临时变量**
列表推导式中使用的变量（例如 `x` 在 `[x for x in iterable]` 中）在 Python 3 中具有**局部作用域**，不会泄漏到外部作用域。

#### 示例（Python 3）：
```python
x = 10
res = [x for x in range(5)]  # 这里的 x 是局部变量
print(res)  # [0, 1, 2, 3, 4]
print(x)    # 10（外部的 x 未被修改）
```

#### 对比 Python 2（旧行为）：
在 Python 2 中，列表推导式中的变量会泄漏到外部作用域：
```python
# Python 2 行为（不适用于 Python 3）
x = 10
res = [x for x in range(5)]
print(x)  # 4（x 被修改了）
```

---

### 2. **列表推导式之后变量的值**
在 Python 3 中，列表推导式中的变量不会影响外部同名变量：
```python
y = 100
squares = [y**2 for y in [1, 2, 3]]
print(squares)  # [1, 4, 9]
print(y)        # 100（外部的 y 未被修改）
```

---

### 3. **列表推导式中的 `if` 条件变量**
即使在 `if` 条件中使用的变量也不会泄漏：
```python
z = 42
filtered = [x for x in range(10) if (z := x % 2 == 0)]  # 使用 :=（海象运算符，Python 3.8+）
print(filtered)  # [0, 2, 4, 6, 8]
print(z)         # False（z 被修改，因为 := 会赋值）
```
> **注意**：如果使用了 `:=`（海象运算符），变量会被赋值到外部作用域。

---

### 4. **嵌套列表推导式的作用域**
嵌套推导式中的变量也是局部的：
```python
matrix = [[1, 2], [3, 4]]
flattened = [x for row in matrix for x in row]
print(flattened)  # [1, 2, 3, 4]
# row 和 x 在外部不可见（除非之前已定义）
```

---

### 5. **`for` 循环 vs 列表推导式**
对比 `for` 循环，它的变量会泄漏：
```python
a = 123
for a in [1, 2, 3]:
    pass
print(a)  # 3（a 被修改）
```

---

### **总结**
| 情况 | 变量生命周期 |
|------|------------|
| Python 3 列表推导式 | 临时变量**不泄漏**到外部 |
| Python 2 列表推导式 | 临时变量**会泄漏**到外部 |
| 使用 `:=` 的推导式 | 变量会赋值到外部作用域 |
| 嵌套推导式 | 每层变量都是局部的 |
| `for` 循环 | 变量会泄漏到外部 |

在 Python 3 中，可以放心使用列表推导式，无需担心变量污染外部作用域。