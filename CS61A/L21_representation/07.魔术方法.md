### **Python 魔术方法（Magic Methods）详解**

魔术方法（Magic Methods），也称为**特殊方法**（Special Methods）或**双下方法**（Dunder Methods），是 Python 中一类以双下划线 `__` 开头和结尾的方法。它们用于定义类的特定行为（如运算符重载、对象初始化等），并由 Python 解释器**自动调用**，而非直接由开发者调用。

---

## **1. 魔术方法的核心作用**
- **定制类行为**：例如 `__init__` 控制对象初始化，`__add__` 定义加法操作。
- **语法糖支持**：如 `obj[key]` 背后是 `__getitem__`，`len(obj)` 背后是 `__len__`。
- **与内置函数交互**：如 `print(obj)` 会调用 `__str__`，`repr(obj)` 会调用 `__repr__`。

---

## **2. 常用魔术方法分类**
### **2.1 对象生命周期**
| 方法                | 触发场景                  | 示例                     |
|---------------------|--------------------------|--------------------------|
| `__init__(self, ...)` | 对象初始化时调用          | `obj = ClassName(args)`  |
| `__del__(self)`      | 对象销毁时调用（慎用）    | `del obj`                |
| `__new__(cls, ...)`  | 创建实例时调用（元类常用）| 控制实例创建过程          |

**示例**：
```python
class Person:
    def __init__(self, name):
        print("初始化！")
        self.name = name
    
    def __del__(self):
        print(f"{self.name} 被销毁了！")

p = Person("Alice")  # 输出: 初始化！
del p                # 输出: Alice 被销毁了！
```

---

### **2.2 字符串表示**
| 方法                | 触发场景                  | 区别                     |
|---------------------|--------------------------|--------------------------|
| `__str__(self)`     | `str(obj)` 或 `print(obj)` | 用户友好的字符串          |
| `__repr__(self)`    | `repr(obj)` 或交互式环境   | 明确的、机器可读的字符串  |

**示例**：
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __str__(self):
        return f"Point at ({self.x}, {self.y})"
    
    def __repr__(self):
        return f"Point(x={self.x}, y={self.y})"

p = Point(1, 2)
print(str(p))   # 输出: Point at (1, 2)
print(repr(p))  # 输出: Point(x=1, y=2)
```

---

### **2.3 运算符重载**
| 方法                | 运算符      | 示例               |
|---------------------|------------|--------------------|
| `__add__(self, other)` | `+`        | `obj1 + obj2`      |
| `__eq__(self, other)`  | `==`       | `obj1 == obj2`     |
| `__lt__(self, other)`  | `<`        | `obj1 < obj2`      |
| `__getitem__(self, key)` | `obj[key]` | 支持索引/切片      |

**示例**：
```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

v1 = Vector(1, 2)
v2 = Vector(3, 4)
v3 = v1 + v2  # 调用 __add__
print(v3.x, v3.y)  # 输出: 4 6
print(v1 == v2)    # 调用 __eq__，输出: False
```

---

### **2.4 上下文管理（`with` 语句）**
| 方法                | 作用                      |
|---------------------|--------------------------|
| `__enter__(self)`   | 进入 `with` 块时调用      |
| `__exit__(self, exc_type, exc_val, exc_tb)` | 退出 `with` 块时调用 |

**示例**：
```python
class Timer:
    def __enter__(self):
        self.start = time.time()
    
    def __exit__(self, *args):
        print(f"耗时: {time.time() - self.start:.2f}s")

with Timer():
    time.sleep(1)  # 输出: 耗时: 1.00s
```

---

### **2.5 其他常用魔术方法**
| 方法                | 触发场景                  |
|---------------------|--------------------------|
| `__len__(self)`     | `len(obj)`               |
| `__call__(self, ...)` | `obj()`（使实例可调用）  |
| `__iter__(self)`    | `for x in obj`（迭代支持）|
| `__getattr__(self, name)` | 访问不存在的属性时调用 |

**示例**：
```python
class Adder:
    def __call__(self, a, b):
        return a + b

add = Adder()
print(add(1, 2))  # 输出: 3（实例像函数一样调用）
```

---

## **3. 魔术方法的设计原则**
1. **一致性**：遵循 Python 内置行为（如 `__eq__` 应返回 `bool`）。
2. **避免滥用**：仅在需要定制行为时使用（如不要用 `__add__` 实现非加法操作）。
3. **性能考量**：魔术方法可能频繁调用（如 `__getitem__`），需高效实现。

---

## **4. 总结**
- **魔术方法赋予类“魔法”能力**，使其与 Python 语法无缝集成。
- **核心用途**：初始化、字符串表示、运算符重载、上下文管理等。
- **关键区别**：
  - `__str__` vs `__repr__`：用户友好 vs 机器可读。
  - `__add__` vs `__iadd__`：`+`  vs `+=`。
- **最佳实践**：优先使用内置协议（如迭代用 `__iter__` 而非手动实现）。