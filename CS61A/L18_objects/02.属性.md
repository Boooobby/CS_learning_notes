# Python 类属性详解

类属性是面向对象编程中的重要概念，Python 中的属性系统非常灵活，下面我将全面介绍与类属性相关的知识点。

## 1. 属性类型

### 实例属性 (Instance Attributes)
- 属于特定实例的属性
- 通过 `self` 在 `__init__` 或其他实例方法中定义
- 每个实例拥有自己的副本

```python
class Person:
    def __init__(self, name):
        self.name = name  # 实例属性

p1 = Person("Alice")
p2 = Person("Bob")
print(p1.name)  # Alice
print(p2.name)  # Bob (每个实例独立)
```

### 类属性 (Class Attributes)
- 属于类本身的属性
- 在类定义中直接声明
- 所有实例共享

```python
class Person:
    species = "Homo sapiens"  # 类属性

p1 = Person()
p2 = Person()
print(p1.species)  # Homo sapiens
print(p2.species)  # Homo sapiens (共享)
```

## 2. 属性访问顺序

Python 使用 **MRO (Method Resolution Order)** 查找属性：
1. 先在实例中查找
2. 找不到则在类中查找
3. 最后在父类中查找

```python
class Example:
    class_attr = "类属性值"
    
    def __init__(self):
        self.instance_attr = "实例属性值"

e = Example()
print(e.instance_attr)  # 先找实例属性
print(e.class_attr)     # 实例没有则找类属性
```

## 3. 属性访问控制

### 命名约定
- `_single_leading_underscore`: 暗示内部使用 (PEP 8约定)
- `__double_leading_underscore`: 名称修饰 (Name Mangling)
- `__double_underscores__`: 魔术方法

### 真正的私有属性
Python 没有真正的私有属性，但可以通过名称修饰实现类似效果：

```python
class Secret:
    def __init__(self):
        self.__secret = "不能直接访问"  # 会被转换为 _Secret__secret

s = Secret()
# print(s.__secret)  # 报错
print(s._Secret__secret)  # 可以访问 (但不推荐)
```

## 4. 属性管理装饰器

### @property
将方法转换为只读属性

```python
class Circle:
    def __init__(self, radius):
        self.radius = radius
    
    @property
    def diameter(self):
        return 2 * self.radius

c = Circle(5)
print(c.diameter)  # 10 (像属性一样访问)
# c.diameter = 20  # 报错 (只读)
```

### @property 完整用法

```python
class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius
    
    @property
    def celsius(self):
        return self._celsius
    
    @celsius.setter
    def celsius(self, value):
        if value < -273.15:
            raise ValueError("温度不能低于绝对零度")
        self._celsius = value
    
    @property
    def fahrenheit(self):
        return (self._celsius * 9/5) + 32
    
    @fahrenheit.setter
    def fahrenheit(self, value):
        self._celsius = (value - 32) * 5/9

t = Temperature(0)
print(t.fahrenheit)  # 32.0
t.fahrenheit = 100
print(t.celsius)     # 37.777...
```

## 5. 动态属性

### 使用 `__dict__`
所有实例属性存储在 `__dict__` 中

```python
class Dynamic:
    pass

d = Dynamic()
d.new_attr = "动态添加的属性"
print(d.__dict__)  # {'new_attr': '动态添加的属性'}
```

### `__slots__` 优化
限制实例属性，节省内存

```python
class Point:
    __slots__ = ['x', 'y']  # 只允许这两个属性
    
    def __init__(self, x, y):
        self.x = x
        self.y = y

p = Point(1, 2)
# p.z = 3  # 报错，因为__slots__限制了属性
```

## 6. 描述符 (Descriptors)

高级特性，控制属性访问逻辑

```python
class PositiveNumber:
    def __set_name__(self, owner, name):
        self.name = name
    
    def __get__(self, instance, owner):
        return instance.__dict__[self.name]
    
    def __set__(self, instance, value):
        if value <= 0:
            raise ValueError("必须是正数")
        instance.__dict__[self.name] = value

class Order:
    quantity = PositiveNumber()  # 描述符实例
    
    def __init__(self, quantity):
        self.quantity = quantity

o = Order(5)
# o.quantity = -1  # 报错
```

## 7. 属性相关魔术方法

### `__getattr__` 和 `__getattribute__`
- `__getattr__`: 当属性不存在时调用
- `__getattribute__`: 访问任何属性时都调用

```python
class Proxy:
    def __init__(self, obj):
        self._obj = obj
    
    def __getattr__(self, name):
        print(f"访问不存在的属性: {name}")
        return getattr(self._obj, name)

p = Proxy([1,2,3])
print(p.append)  # 访问不存在的属性: append
```

### `__setattr__` 和 `__delattr__`
控制属性赋值和删除行为

```python
class Immutable:
    def __init__(self, value):
        super().__setattr__('value', value)
    
    def __setattr__(self, name, value):
        raise AttributeError("不可变对象")
    
    def __delattr__(self, name):
        raise AttributeError("不可变对象")

im = Immutable(42)
# im.value = 10  # 报错
```

## 8. 最佳实践

1. **明确区分实例属性和类属性**
2. **使用@property实现计算属性**
3. **优先使用受保护的属性(_前缀)而非私有属性**
4. **考虑使用__slots__优化内存**
5. **描述符适合复用属性逻辑**
6. **谨慎使用魔术方法，避免过度设计**

理解这些属性相关概念，可以帮助你编写更Pythonic、更高效的面向对象代码。