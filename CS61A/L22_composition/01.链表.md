# Python中的链表详解

链表是一种常见的数据结构，与Python内置的列表(list)不同，链表通过节点之间的引用(指针)来连接数据元素。下面我将详细介绍Python中链表的实现和应用。

## 基本概念

链表由一系列节点组成，每个节点包含：
1. 数据域 - 存储数据
2. 指针域 - 指向下一个节点

链表类型：
- 单链表 - 每个节点只有一个指向下一个节点的指针
- 双向链表 - 每个节点有指向前一个和后一个节点的指针
- 循环链表 - 尾节点指向头节点形成环

## 单链表实现

```python
class ListNode:
    """链表节点类"""
    def __init__(self, val=0, next=None):
        self.val = val    # 数据域
        self.next = next   # 指针域

class LinkedList:
    """链表类"""
    def __init__(self):
        self.head = None   # 头节点
    
    def append(self, val):
        """在链表末尾添加节点"""
        new_node = ListNode(val)
        if not self.head:
            self.head = new_node
            return
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node
    
    def prepend(self, val):
        """在链表头部添加节点"""
        new_node = ListNode(val, self.head)
        self.head = new_node
    
    def delete(self, val):
        """删除第一个值为val的节点"""
        if not self.head:
            return
        
        if self.head.val == val:
            self.head = self.head.next
            return
        
        current = self.head
        while current.next:
            if current.next.val == val:
                current.next = current.next.next
                return
            current = current.next
    
    def search(self, val):
        """查找值为val的节点"""
        current = self.head
        while current:
            if current.val == val:
                return True
            current = current.next
        return False
    
    def display(self):
        """打印链表"""
        current = self.head
        while current:
            print(current.val, end=" -> ")
            current = current.next
        print("None")
```

## 双向链表实现

```python
class DoublyListNode:
    """双向链表节点"""
    def __init__(self, val=0, prev=None, next=None):
        self.val = val
        self.prev = prev
        self.next = next

class DoublyLinkedList:
    """双向链表类"""
    def __init__(self):
        self.head = None
        self.tail = None
    
    def append(self, val):
        """在末尾添加节点"""
        new_node = DoublyListNode(val)
        if not self.head:
            self.head = self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node
    
    def prepend(self, val):
        """在头部添加节点"""
        new_node = DoublyListNode(val, None, self.head)
        if self.head:
            self.head.prev = new_node
        else:
            self.tail = new_node
        self.head = new_node
    
    def delete(self, val):
        """删除节点"""
        current = self.head
        while current:
            if current.val == val:
                if current.prev:
                    current.prev.next = current.next
                else:
                    self.head = current.next
                
                if current.next:
                    current.next.prev = current.prev
                else:
                    self.tail = current.prev
                return
            current = current.next
```

## 链表常用操作

1. **反转链表**
```python
def reverse_list(head):
    prev = None
    current = head
    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    return prev
```

2. **检测环**
```python
def has_cycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

3. **合并两个有序链表**
```python
def merge_two_lists(l1, l2):
    dummy = ListNode()
    current = dummy
    
    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    
    current.next = l1 if l1 else l2
    return dummy.next
```

## 链表与列表的比较

| 特性        | 链表                      | Python列表(list)         |
|------------|--------------------------|-------------------------|
| 内存分配    | 动态分配，不连续          | 连续内存分配            |
| 插入/删除   | O(1) (已知位置)           | O(n) (需要移动元素)      |
| 随机访问    | O(n)                      | O(1)                    |
| 内存开销    | 每个节点需要额外存储指针   | 只有数据存储             |

## 应用场景

1. 实现栈和队列
2. 处理大数据集(避免插入/删除时的数据移动)
3. 实现图、树等更复杂的数据结构
4. 需要频繁插入删除操作的场景

链表是计算机科学中基础且重要的数据结构，理解其原理和实现对于编程和算法学习至关重要。