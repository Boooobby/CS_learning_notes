# Python装饰器(Decorators)详解

装饰器是Python中一种强大的语法特性，它允许在不修改原函数代码的情况下，动态地扩展函数的功能。

## 基本概念

装饰器本质上是一个**可调用对象**（通常是函数或类），它接受一个函数作为输入并返回一个新的函数。

## 基本语法

```python
@decorator
def function():
    pass
```

等价于：
```python
def function():
    pass
function = decorator(function)
```

## 简单装饰器示例

```python
def simple_decorator(func):
    def wrapper():
        print("Before function call")
        func()
        print("After function call")
    return wrapper

@simple_decorator
def say_hello():
    print("Hello!")

say_hello()
```

输出：
```
Before function call
Hello!
After function call
```

## 装饰器的常见用途

1. **日志记录**
```python
def log(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args: {args}, kwargs: {kwargs}")
        return func(*args, **kwargs)
    return wrapper
```

2. **计时器**
```python
import time

def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} executed in {end-start:.4f} seconds")
        return result
    return wrapper
```

3. **权限验证**
```python
def requires_auth(func):
    def wrapper(*args, **kwargs):
        if not current_user.is_authenticated:
            raise PermissionError("Authentication required")
        return func(*args, **kwargs)
    return wrapper
```

## 带参数的装饰器

```python
def repeat(num_times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(num_times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(num_times=3)
def greet(name):
    print(f"Hello {name}")

greet("Alice")
```

## 类装饰器

装饰器也可以是类：

```python
class CountCalls:
    def __init__(self, func):
        self.func = func
        self.num_calls = 0

    def __call__(self, *args, **kwargs):
        self.num_calls += 1
        print(f"Call {self.num_calls} of {self.func.__name__}")
        return self.func(*args, **kwargs)

@CountCalls
def say_hello():
    print("Hello!")

say_hello()
say_hello()
```

## 保留函数元信息

使用`functools.wraps`保留原函数的元信息：

```python
from functools import wraps

def my_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        """Wrapper docstring"""
        return func(*args, **kwargs)
    return wrapper
```

## 多个装饰器的执行顺序

```python
@decorator1
@decorator2
def func():
    pass
```
等价于：
```python
func = decorator1(decorator2(func))
```

## 实际应用场景

1. Flask路由装饰器：
```python
@app.route('/')
def home():
    return "Hello World"
```

2. Django登录验证：
```python
@login_required
def profile(request):
    return render(request, 'profile.html')
```

3. 缓存装饰器：
```python
@lru_cache(maxsize=100)
def expensive_function(x):
    # 复杂计算
    return result
```

装饰器是Python中非常强大的工具，合理使用可以使代码更加简洁、可读和可维护。