在 Python 中，`@` 符号主要有两种用途，都与 **装饰器（Decorator）** 相关：

---

### 1. **装饰器语法（最常见用法）**
`@` 符号用于应用装饰器，它可以修改或增强函数/类的行为，而无需更改其原始代码。

#### 基本格式：
```python
@decorator_name
def function_name():
    pass
```

#### 示例：
```python
def log_time(func):
    def wrapper(*args, **kwargs):
        import time
        start = time.time()
        result = func(*args, **kwargs)
        print(f"函数 {func.__name__} 耗时: {time.time() - start:.2f}秒")
        return result
    return wrapper

@log_time  # 使用 @ 应用装饰器
def slow_function():
    import time
    time.sleep(1)

slow_function()  # 输出: "函数 slow_function 耗时: 1.00秒"
```

#### 等价于：
```python
def slow_function():
    ...
slow_function = log_time(slow_function)  # 手动装饰
```

---

### 2. **矩阵乘法运算符（Python 3.5+）**
`@` 还可作为 **矩阵乘法运算符**（需实现 `__matmul__` 方法），但较少使用。

#### 示例：
```python
import numpy as np

A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])
print(A @ B)  # 矩阵乘法，输出: [[19 22], [43 50]]
```

---

### 关键点：
1. **装饰器本质**：  
   `@decorator` 是一种语法糖，它会将被装饰的函数/类作为参数传递给装饰器函数。

2. **常见用途**：
   - 日志记录
   - 性能测试（计时）
   - 权限验证
   - 缓存（如 `@functools.lru_cache`）

3. **支持多层装饰器**：
   ```python
   @decorator1
   @decorator2
   def func():
       pass
   ```
   执行顺序：从下往上（`decorator2` 先应用，`decorator1` 后应用）。

---

### 为什么需要 `@` 语法？
- **代码更简洁**：避免手动赋值（如 `func = decorator(func)`）。
- **可读性更强**：明确标识被装饰的函数/类。