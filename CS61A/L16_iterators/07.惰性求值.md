# Python 迭代器的惰性求值（Lazy Evaluation）详解

惰性求值是迭代器最重要的特性之一，也是处理大数据集和无限序列的关键机制。

## 1. 什么是惰性求值？

惰性求值（Lazy Evaluation）是一种计算策略，特点是：
- **需要时才计算**：只在真正请求值时才会进行计算
- **不预计算**：不会提前生成所有可能的值
- **按需生成**：一次只生成一个值，保持最小内存占用

与之相对的是**急切求值**（Eager Evaluation），如列表会立即计算并存储所有元素。

## 2. 迭代器如何实现惰性求值？

迭代器通过 `__next__()` 方法实现惰性求值：

```python
class SquareIterator:
    def __init__(self, max_num):
        self.max = max_num
        self.current = 0
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.current >= self.max:
            raise StopIteration
        result = self.current ** 2
        self.current += 1
        return result

# 使用时
squares = SquareIterator(5)  # 此时没有计算任何平方数
print(next(squares))  # 0 (第一次调用时计算0的平方)
print(next(squares))  # 1 (第二次调用时计算1的平方)
```

## 3. 惰性求值的核心优势

### 3.1 处理无限序列

```python
import itertools

# 无限计数器
counter = itertools.count()  # 不会耗尽内存

# 获取前10个
for i in counter:
    if i >= 10:
        break
    print(i)
```

### 3.2 高效处理大型数据集

```python
def read_large_file(file_path):
    with open(file_path) as f:
        for line in f:  # 一次只读取一行到内存
            yield line.strip()

# 处理10GB文件但只使用极少内存
for line in read_large_file("huge.log"):
    process(line)
```

### 3.3 节省计算资源

```python
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

fib = fibonacci()
print(next(fib))  # 0 (只计算到第一个数)
print(next(fib))  # 1 (只计算到第二个数)
```

## 4. 惰性求值的实际应用场景

### 4.1 数据库查询

```python
# 伪代码示例
def query_db(query):
    conn = connect_to_database()
    cursor = conn.execute(query)
    for row in cursor:  # 惰性获取，不一次性加载所有结果
        yield row
    conn.close()
```

### 4.2 流式数据处理

```python
def process_stream(stream):
    for packet in stream:  # 数据包可能永远不断
        if is_valid(packet):
            yield transform(packet)
```

### 4.3 机器学习批量加载

```python
def batch_loader(dataset, batch_size):
    for i in range(0, len(dataset), batch_size):
        yield dataset[i:i+batch_size]  # 只在需要时加载一个batch
```

## 5. 惰性求值的注意事项

1. **时效性**：值只在被请求时计算，可能受外部变化影响
   ```python
   nums = [1, 2, 3]
   iterator = iter(nums)
   nums.append(4)  # 修改原始列表
   print(list(iterator))  # [1, 2, 3, 4] (视图特性，不是所有迭代器都这样)
   ```

2. **一次性消费**：
   ```python
   data = iter([1, 2, 3])
   sum(data)  # 6
   sum(data)  # 0 (迭代器已耗尽)
   ```

3. **调试困难**：由于不立即执行，错误可能延迟出现

## 6. 强制提前求值的方法

如果需要所有值，可以转换为其他类型：

```python
lazy = iter([1, 2, 3])  # 迭代器
eager = list(lazy)      # 立即求值为列表 [1, 2, 3]
```

## 7. 生成器表达式也是惰性的

```python
squares = (x**2 for x in range(1000000))  # 不立即计算
print(next(squares))  # 0 (第一次使用时计算)
print(next(squares))  # 1
```

## 性能对比示例

```python
import time
import sys

# 急切求值
def eager_range(n):
    result = []
    i = 0
    while i < n:
        result.append(i)
        i += 1
    return result

# 惰性求值
def lazy_range(n):
    i = 0
    while i < n:
        yield i
        i += 1

# 测试内存使用
eager = eager_range(1000000)
lazy = lazy_range(1000000)

print(sys.getsizeof(eager))  # 约8448728字节（存储了全部元素）
print(sys.getsizeof(lazy))   # 约120字节（只是一个生成器对象）
```

惰性求值使Python能够高效处理：
- 内存放不下的大数据集
- 理论上无限的序列
- 需要流式处理的数据源
- 昂贵的计算任务（按需计算）

理解这一特性是掌握Python高效编程的关键之一。