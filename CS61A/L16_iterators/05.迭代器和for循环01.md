# Python 迭代器与 for 循环的关系

迭代器和 for 循环在 Python 中紧密相关，理解它们的关系对于编写高效、优雅的 Python 代码非常重要。

## 1. for 循环的内部机制

Python 的 for 循环实际上是基于迭代器协议实现的。当您写：

```python
for item in iterable:
    print(item)
```

Python 解释器在背后会执行以下操作：

1. 调用 `iter(iterable)` 获取一个迭代器对象
2. 重复调用 `next()` 方法从迭代器获取下一个值
3. 当遇到 `StopIteration` 异常时，循环终止

这相当于：

```python
iterator = iter(iterable)
while True:
    try:
        item = next(iterator)
        print(item)
    except StopIteration:
        break
```

## 2. 可迭代对象 vs 迭代器

- **可迭代对象 (Iterable)**: 实现了 `__iter__()` 方法的对象
  - 如列表、元组、字符串、字典、集合等
  - 可以用于 for 循环
  - 每次调用 `iter()` 都会返回一个新的迭代器

- **迭代器 (Iterator)**: 实现了 `__iter__()` 和 `__next__()` 方法的对象
  - `__iter__()` 通常返回 self
  - `__next__()` 返回下一个值或抛出 StopIteration
  - 是"一次性"的，遍历完后需要重新创建

## 3. 常见迭代模式

### 3.1 直接使用 for 循环

```python
# 遍历列表
numbers = [1, 2, 3]
for num in numbers:
    print(num)

# 遍历字典键
d = {'a': 1, 'b': 2}
for key in d:  # 等同于 d.keys()
    print(key)
```

### 3.2 手动使用迭代器

```python
numbers = [1, 2, 3]
iterator = iter(numbers)

print(next(iterator))  # 1
print(next(iterator))  # 2
print(next(iterator))  # 3
# print(next(iterator))  # 抛出 StopIteration
```

### 3.3 自定义可迭代类

```python
class CountDown:
    def __init__(self, start):
        self.start = start
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.start <= 0:
            raise StopIteration
        self.start -= 1
        return self.start + 1

for num in CountDown(3):
    print(num)  # 输出 3, 2, 1
```

## 4. 迭代器的优势

1. **惰性计算**：只在需要时生成值，节省内存
2. **无限序列**：可以表示无限序列（如 itertools.count）
3. **一致性**：统一的迭代接口，适用于所有集合类型
4. **高效**：避免一次性生成所有元素

## 5. 常见迭代工具

### 5.1 enumerate()

```python
fruits = ['apple', 'banana', 'cherry']
for i, fruit in enumerate(fruits, start=1):
    print(f"{i}. {fruit}")
```

### 5.2 zip()

```python
names = ['Alice', 'Bob', 'Charlie']
scores = [85, 92, 78]
for name, score in zip(names, scores):
    print(f"{name}: {score}")
```

### 5.3 itertools 模块

```python
import itertools

# 无限计数器
for i in itertools.count(10, 2):
    if i > 20:
        break
    print(i)  # 10, 12, 14, 16, 18, 20

# 排列组合
for p in itertools.permutations('ABC', 2):
    print(p)  # AB, AC, BA, BC, CA, CB
```

## 6. 注意事项

1. **迭代器是一次性的**：
   ```python
   numbers = [1, 2, 3]
   iterator = iter(numbers)
   list(iterator)  # [1, 2, 3]
   list(iterator)  # [] (已经耗尽)
   ```

2. **避免在迭代中修改集合**：
   ```python
   # 不安全的做法
   d = {'a': 1, 'b': 2}
   for k in d:
       del d[k]  # 可能引发 RuntimeError
   
   # 安全的做法
   for k in list(d.keys()):
       del d[k]
   ```

3. **生成器是特殊的迭代器**：
   ```python
   def squares(n):
       for i in range(n):
           yield i ** 2
   
   for num in squares(3):
       print(num)  # 0, 1, 4
   ```

理解迭代器和 for 循环的关系可以帮助您：
- 编写更高效的代码
- 创建自定义的可迭代对象
- 更好地利用 Python 的迭代工具
- 处理大型数据集而不会耗尽内存