好的，我们来深入讲解 Scheme 中的变量作用域。Scheme 的作用域系统非常优雅和强大，主要体现在**词法作用域**（Lexical Scoping）和**块作用域**（Block Scoping）上。

## 核心概念：词法作用域

Scheme 采用**词法作用域**（也称为静态作用域），这意味着变量的可见性由代码的物理结构决定，而不是运行时调用栈。

### 基本作用域形式

#### 1. `let` - 局部绑定

`let` 创建局部作用域，绑定只在 `let` 体内有效。

```scheme
(let ((x 10)
      (y 20))
  (+ x y))  ; ⇒ 30

; x 和 y 在这里不可访问
```

#### 2. `let*` - 顺序绑定

`let*` 允许后续绑定使用前面绑定的变量。

```scheme
(let* ((x 10)
       (y (+ x 5)))  ; 可以使用 x
  (+ x y))           ; ⇒ 25

; 等效于嵌套的 let
(let ((x 10))
  (let ((y (+ x 5)))
    (+ x y)))
```

#### 3. `letrec` - 递归绑定

`letrec` 允许绑定相互引用，常用于定义递归函数。

```scheme
(letrec ((factorial
          (lambda (n)
            (if (<= n 1)
                1
                (* n (factorial (- n 1)))))))
  (factorial 5))     ; ⇒ 120
```

## 作用域链和闭包

### 闭包（Closure）

Scheme 的函数会"记住"它们被创建时的环境，这就是闭包。

```scheme
(define (make-adder n)
  (lambda (x)        ; 这个lambda记住了n的值
    (+ x n)))

(define add5 (make-adder 5))
(define add10 (make-adder 10))

(add5 3)   ; ⇒ 8
(add10 3)  ; ⇒ 13
```

### 作用域嵌套

内层作用域可以访问外层作用域的变量：

```scheme
(let ((x 10))
  (let ((y 20))
    (let ((z 30))
      (+ x y z))))  ; ⇒ 60，可以访问所有外层变量
```

## 特殊的作用域形式

### 1. `define` 的作用域

在过程（函数）内部的 `define` 创建局部变量：

```scheme
(define (outer x)
  (define inner-var 100)  ; 局部变量
  (define (inner y)       ; 局部函数
    (+ x y inner-var))
  (inner 5))

(outer 10)  ; ⇒ 115
; inner-var 和 inner 在这里不可访问
```

### 2. `set!` 和变量修改

`set!` 修改已有绑定的值，但必须遵守作用域规则：

```scheme
(define counter 0)

(define (increment)
  (set! counter (+ counter 1))
  counter)

(increment)  ; ⇒ 1
(increment)  ; ⇒ 2

(let ((x 10))
  (set! x 20)  ; 修改局部变量x
  x)           ; ⇒ 20
```

## 作用域的实际应用

### 1. 信息隐藏（封装）

```scheme
(define (make-bank-account initial-balance)
  (let ((balance initial-balance))
    (lambda (action amount)
      (cond ((eq? action 'deposit)
             (set! balance (+ balance amount))
             balance)
            ((eq? action 'withdraw)
             (if (>= balance amount)
                 (begin (set! balance (- balance amount))
                        balance)
                 "Insufficient funds"))
            ((eq? action 'balance)
             balance)
            (else "Unknown action")))))

(define my-account (make-bank-account 100))
(my-account 'deposit 50)   ; ⇒ 150
(my-account 'withdraw 30)  ; ⇒ 120
(my-account 'balance)      ; ⇒ 120
; balance 变量被完美隐藏
```

### 2. 配置管理

```scheme
(define (with-config config thunk)
  (let ((old-config (current-config)))
    (dynamic-wind
      (lambda () (set-config! config))
      thunk
      (lambda () (set-config! old-config)))))

; 使用特定配置执行代码
(with-config 'production
  (lambda ()
    (run-application)))
```

### 3. 动态作用域模拟

虽然 Scheme 是词法作用域，但可以用参数来模拟动态作用域：

```scheme
(define current-user (make-parameter "anonymous"))

(define (greet)
  (display (string-append "Hello, " (current-user) "!\n")))

(parameterize ((current-user "Alice"))
  (greet))  ; 输出: Hello, Alice!

(greet)     ; 输出: Hello, anonymous!
```

## 作用域相关的特殊形式

### 1. `lambda` 参数作用域

```scheme
((lambda (x y)      ; x 和 y 是参数，作用域在lambda体内
   (+ x y))
 5 10)              ; ⇒ 15
```

### 2. 条件语句中的作用域

```scheme
(let ((x 10))
  (if (> x 5)
      (let ((y 20))   ; y 只在then分支中有效
        (+ x y))
      (let ((z 30))   ; z 只在else分支中有效  
        (+ x z))))
```

## 作用域规则总结

1. **最近嵌套规则**：变量引用解析到最近的包含绑定
2. **遮蔽（Shadowing）**：内层绑定可以遮蔽外层同名绑定
3. **不可穿透性**：外层不能访问内层的局部变量
4. **闭包记忆**：函数记住其创建时的环境

```scheme
(define x 100)  ; 全局x

(let ((x 10))   ; 局部x遮蔽全局x
  (let ((x 20)) ; 更内层的x遮蔽外层x
    x))         ; ⇒ 20 (最近绑定)

; 这里 x 还是 100 (全局x)
```

## 常见作用域错误

### 1. 变量未定义

```scheme
(let ()
  (set! y 10))  ; 错误: y 未定义
```

### 2. 错误的遮蔽

```scheme
(define x 10)

(let ((x 20)
      (y x))    ; 这里的x是全局的10，不是局部的20
  (+ x y))      ; ⇒ 30 (20 + 10)
```

### 3. `letrec` 的限制

```scheme
(letrec ((x y)   ; 错误: y 在初始化时还未定义
         (y 10))
  (+ x y))
```

## 高级作用域技巧

### 1. 模块模式

```scheme
(define math-module
  (let ((pi 3.14159))
    (define (circle-area r)
      (* pi r r))
    (define (circle-circumference r)
      (* 2 pi r))
    (lambda (op . args)
      (apply (case op
              ((area) circle-area)
              ((circumference) circle-circumference))
             args))))

(math-module 'area 5)  ; ⇒ 78.53975
```

### 2. 环境传递

```scheme
(define (eval-in-env expr env)
  (cond ((number? expr) expr)
        ((symbol? expr) (env expr))
        ((list? expr)
         (apply (eval-in-env (car expr) env)
                (map (lambda (x) (eval-in-env x env))
                     (cdr expr))))))

(let ((env (lambda (sym)
             (case sym
               ((+) +)
               ((-) -)
               ((x) 10)
               ((y) 20)))))
  (eval-in-env '(+ x y) env))  ; ⇒ 30
```

Scheme 的作用域系统是其函数式编程能力的核心基础，通过词法作用域和闭包，可以构建出非常模块化、封装良好的代码结构。