好的，除了最基本的 `cons`, `car`, `cdr` 之外，Scheme 提供了许多常用的内置列表函数。这些函数大大简化了列表操作。

## 核心列表函数

### 1. 基础查询函数

| 函数 | 描述 | 示例 |
|------|------|------|
| `(null? list)` | 检查列表是否为空 | `(null? '())` → `#t` |
| `(pair? obj)` | 检查对象是否为序对（非空列表） | `(pair? '(1))` → `#t` |
| `(list? obj)` | 检查对象是否为正确结构的列表 | `(list? '(1 2))` → `#t` |

### 2. 构造和拼接函数

| 函数 | 描述 | 示例 |
|------|------|------|
| `(list obj ...)` | 用参数创建新列表 | `(list 1 2 3)` → `(1 2 3)` |
| `(append list1 list2 ...)` | 拼接多个列表 | `(append '(1 2) '(3 4))` → `(1 2 3 4)` |
| `(reverse list)` | 反转列表元素顺序 | `(reverse '(1 2 3))` → `(3 2 1)` |

### 3. 元素访问函数

| 函数 | 描述 | 示例 |
|------|------|------|
| `(length list)` | 返回列表长度 | `(length '(a b c))` → `3` |
| `(list-ref list k)` | 返回列表中第k个元素（从0开始） | `(list-ref '(a b c) 1)` → `b` |
| `(member obj list)` | 查找元素，返回从该元素开始的子列表 | `(member 'b '(a b c))` → `(b c)` |
| `(memq obj list)` | 类似 `member`，但使用 `eq?` 比较 | `(memq 'b '(a b c))` → `(b c)` |
| `(memv obj list)` | 类似 `member`，但使用 `eqv?` 比较 | `(memv 2 '(1 2 3))` → `(2 3)` |

### 4. 高阶函数（函数式编程核心）

| 函数 | 描述 | 示例 |
|------|------|------|
| `(map proc list1 list2 ...)` | 对列表每个元素应用过程 | `(map abs '(-1 2 -3))` → `(1 2 3)` |
| `(for-each proc list1 list2 ...)` | 类似map，但用于副作用，返回未定义 | `(for-each display '(1 2 3))` → 显示123 |
| `(filter pred list)` | 过滤满足条件的元素 | `(filter even? '(1 2 3 4))` → `(2 4)` |
| `(fold-left proc init list)` | 从左向右折叠（累积） | `(fold-left + 0 '(1 2 3))` → `6` |
| `(fold-right proc init list)` | 从右向左折叠 | `(fold-right cons '() '(1 2 3))` → `(1 2 3)` |

### 5. 列表操作函数

| 函数 | 描述 | 示例 |
|------|------|------|
| `(assoc key alist)` | 在关联列表中按键查找 | `(assoc 'b '((a 1)(b 2)))` → `(b 2)` |
| `(assq key alist)` | 类似assoc，使用eq?比较 | `(assq 'b '((a 1)(b 2)))` → `(b 2)` |
| `(assv key alist)` | 类似assoc，使用eqv?比较 | `(assv 2 '((1 a)(2 b)))` → `(2 b)` |

## 实用示例

### 1. 列表处理
```scheme
;; 计算平方列表
(map (lambda (x) (* x x)) '(1 2 3 4)) ; → (1 4 9 16)

;; 筛选正数
(filter positive? '(-1 2 -3 4 0 5)) ; → (2 4 5)

;; 列表求和
(fold-left + 0 '(1 2 3 4)) ; → 10
```

### 2. 列表操作组合
```scheme
;; 获取列表第二个元素
(cadr '(a b c d)) ; → b
;; 等价于
(car (cdr '(a b c d))) ; → b

;; 获取列表最后一个元素
(car (reverse '(a b c d))) ; → d
;; 或者
(list-ref '(a b c d) (- (length '(a b c d)) 1)) ; → d
```

### 3. 关联列表操作
```scheme
(define phonebook '((john "555-1234")
                    (mary "555-5678")
                    (bob "555-9012")))

(assoc 'mary phonebook) ; → (mary "555-5678")
(assq 'john phonebook)  ; → (john "555-1234")
```

### 4. 复杂列表处理
```scheme
;; 扁平化嵌套列表
(define (flatten lst)
  (cond ((null? lst) '())
        ((pair? (car lst)) 
         (append (flatten (car lst)) (flatten (cdr lst))))
        (else 
         (cons (car lst) (flatten (cdr lst))))))

(flatten '((1 2) (3 (4 5)))) ; → (1 2 3 4 5)
```

## 常用组合模式

```scheme
;; 1. 遍历并处理
(map (lambda (x) (* x 2)) '(1 2 3)) ; 每个元素乘以2

;; 2. 过滤并处理
(map car (filter pair? '((1) 2 (3 4) 5))) ; 过滤出子列表并取第一个元素

;; 3. 转换和累积
(fold-left (lambda (acc x) (+ acc (* x x))) 0 '(1 2 3)) ; 计算平方和

;; 4. 查找和提取
(define found (member 'target my-list))
(if found (car found) #f) ; 如果找到则返回该元素
```

这些内置函数构成了 Scheme 列表处理的核心工具集，熟练掌握它们可以极大地提高编程效率。