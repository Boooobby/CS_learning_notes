结构体的字节对齐规则是编译器在分配结构体成员的内存时遵循的标准。字节对齐规则的目的在于让数据访问更加高效。以下是常见的字节对齐规则：

### 1. 基本对齐规则
- **每个成员的地址必须是其对齐系数的整数倍**。
  - 例如，`int`（通常为4字节）在4字节对齐的系统中，其地址应是4的倍数。
  - `char`（通常为1字节）可以放置在任何地址，因为1字节对齐无需额外对齐。
  
### 2. 结构体内成员的排列
- **结构体的每个成员的偏移量是该成员类型大小的整数倍**，若不满足此要求，则会插入填充字节（Padding）。
- 编译器会根据成员类型的大小自动插入必要的填充字节，以满足对齐要求。

### 3. 结构体的整体对齐
- **结构体的总大小必须是最大成员对齐系数的整数倍**。这是为了保证结构体数组中每个结构体实例的起始地址也对齐。
- 如果结构体大小不是最大对齐系数的整数倍，则在结构体末尾插入填充字节，使其达到该整数倍。

### 举例说明
假设在一个系统中，`int` 需要4字节对齐，`char`需要1字节对齐，`double`需要8字节对齐。考虑如下结构体：

```c
struct Example {
    char a;      // 1字节
    int b;       // 4字节
    double c;    // 8字节
};
```

#### 分析内存布局
1. `a` 占用第1个字节的位置 `[0]`。
2. `b` 需要4字节对齐，所以它会从位置 `[4]` 开始，占用 `[4, 7]`。因此，位置 `[1, 3]` 插入了3字节的填充。
3. `c` 需要8字节对齐，所以它会从位置 `[8]` 开始，占用 `[8, 15]`。

整个结构体的大小因此为 16 字节。  
- `a` 占用1字节。
- `b` 占用4字节，但之前填充了3字节，使其从第4字节开始。
- `c` 占用8字节，总大小为 `16` 字节，无需额外填充。

### 结构体数组的对齐
在结构体数组中，编译器会确保每个结构体实例都对齐。因此，整个结构体的大小必须是最大对齐系数（这里为8字节）的整数倍，以保证下一个结构体实例的起始地址也对齐。

### 对齐系数的控制
编译器允许我们调整结构体的对齐方式。例如，在GCC中可以使用 `#pragma pack(n)` 指令设置对齐系数为 `n` 字节，从而减少填充空间。