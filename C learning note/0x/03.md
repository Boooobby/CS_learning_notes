# C语言学习笔记
## 第三部分（细碎点 变量 指针 字符串 浮点数精度）

### 一、细碎知识点
1. sizeof（）括号内部不可以作运算
2. c中用到布尔类型需`#include<stdbool.h>`
3. 不同数据类型内存大小：

|类型|内存|
|:--:|:--:|
|char|1B|
|short|2B|
|int|4B(取决于编译器 CPU)|
|long|4B(取决于编译器 CPU)|
|long long|8B|
|float|4B|
|double|8B|
|long double|16B|

- 注意：
    1. 1B（Byte） = 8个字长（Bit）
    2. float可以表示的有效数字只有7个数字 double15个
    3. 字符常量的内存数为4B（编译时自动转换成ASCII值 并看成是int类型）

1. 浮点数表达存在误差：计算机内部只有离散的数 不像数学中数轴上 任意两个不同的数 中间还有无穷多个数 故而表示小数的时候 存在精度误差（取最靠近的那个计算机可表达的数）
2. 因为浮点数精度误差的问题 当`f1 == f2`时 有可能结果为false
    - 解决方案1：用取绝对值函数`fabs()` 如`fabs(f1 - f2) < 1e-12;`
    - 解决方案2：小数想办法转换为整数来计算（整数是精确的）
3. 浮点数内部计算采取编码的形式：![alt text](image.png)
    - 有专门的硬件来计算浮点数 并且float和double的计算都是一样的
4. 如果没有特殊需要：整型用int 浮点型用double
5. 常用ASCII码：' '-32 '0'-48 'A'-65 'a'-97
6. 参数进入函数之前需要被初始化
7.  C语言不允许函数嵌套定义
8.  对于负整数 当其用无符号整数类型来输出时（%u）会先将其转换成二进制数 然后再按照无符号整数类型的二进制数来转换成无符号整数类型
    - 例：`int a = -1;` `printf("%u", a);`会输出2^32 - 1那个数（原来int的-1编码为11111……111 共有32个1）
    - 同理 对于`unsigned char a = -1;`若将其以int形式输入 会得到2^8 - 1
9.  数组下标越界：只会在程序运行后出问题 编译器不会检查出问题
10. 数组作为函数的参数时 往往需要用另一个参数来传入数组的大小 并且传入数组后 不可用sizeof来计算数组的大小
11. 当要输入不定数量的元素时 一般情况下数组不太好用（数组大小时确定的）
12. 对于用变量来初始化另一个变量：当用于初始化变量的那个变量的值改变时 被初始化的那一个变量不会因此而改变
13. 对于二维数组的定义：列数不可以省略 行数可以省略（先行后列）
14. 垂直制表符`\v`在下方生成一个空格
15. 响铃符`\a`发出声音
16. 尽量不要负数取模
17. main函数内部是有参数的：`int main(int argc, char const* argv[])`
18. `\` 续行符 可以将一行代码写到多行上去
19. **计算机一秒内处理10^8 ~ 10^9次运算**
20. 

### 二、变量
1. 变量的生存期和作用域：
    - 生存期：何时变量出现 何时变量消亡
    - 作用域：在什么范围内可以访问这个变量
    - 对于本地变量（局部变量）：两者答案是统一的——大括号内（块）
2. 每一个函数 都有其自身的变量空间
3. 本地变量规则：
    1. 本地变量是定义在块内的
      - 可以是函数的块内
      - 可以是语句的块内（如if语句中的大括号）
    2. 程序运行进入这个块之前 其中的变量不存在 离开这个块时 其中变量消失
    3. 块外面定义的变量 在块里仍然有效
    4. 在块里定义了和块外面同名的变量 会掩盖外面的
    5. 同一个块里不可定义同名变量
    6. 本地变量不会被默认初始化 需要显式初始化它
4. **当全局变量和局部变量同名时，在局部变量的作用域内，局部变量会隐藏（shadow）全局变量。也就是说，在该作用域内访问该名字时，实际访问的是局部变量，而不是全局变量**
5. 关于存储类别：
   - 四种：自动auto 静态static 寄存器register 外部extern
    1. auto：
       1. 自动存储类别的变量是在函数内部定义的局部变量，如果不专门声明为其他存储类别，则默认为自动存储类别。这些变量在函数调用时分配内存，在函数调用结束时释放内存
    2. **static**：
       1. 静态存储类别的变量在程序执行期间保持其值，即使函数调用结束也不会释放其内存。静态变量可以在函数内部或外部定义
       2. 函数内部定义：这些变量在函数调用结束后仍然存在，但只能被**该函数**访问
       3. 函数外部定义：这些变量具有文件作用域，只能在本文件内被访问和修改
       4. **注意**：static变量只会被初始化一次 且若是未被初始化 则自动初始化为0
    3. register：
       1. 寄存器存储类别的变量存储在CPU的寄存器中，而不是内存中。这种存储方式可以提高变量的访问速度。然而，实际是否存储在寄存器中取决于编译器的优化策略
       2. 注意：放在寄存器中的变量不可以被取地址`&`
    4. extern：
       1. 外部存储类别的变量是在函数外部定义的全局变量，它们在整个程序运行期间都存在，并且可以被程序中的任何函数访问。如果在一个文件中定义了外部变量，并希望在其他文件中也能访问它，可以使用`extern`关键字在其他文件中声明该变量
       2. 例：`int a = 10;` `extern int a;` `printf("%d", a);`
       3. 注意：全局变量默认是extern的 若是不想让这个变量在其他文件上被访问 则可以在前面加上static
       4. 注意：自己定义的函数都是extern的 且引用的时候不需要像变量一样声明一下 当不想被访问时同理 加static
    - 总结：不同的存储类别有着不同的**作用域和生命周期** 实践时按需操作
6. 
### 三、指针
1. 在不同操作系统下 指针类型的大小不同：32位——4byte 64位——8byte
2. 取地址符&：在32位操作系统下 当指针类型强转为整型时 得到的结果相同 而在64位下 得到结果不同
3. &的右边必须是一个变量 而不能是表达式
4. `a`是数组首地址的指针 而`&a`是指向所有数组元素的指针
5. 注意：在定义指针时
   - `int* p, q;`此时p为指针类型 q为整型
   - `int *p, *q;`此时两者都为指针类型
6. 在一个指针变量还没有指向任何的变量之前 不可以使用这个指针（野指针）
    - 例：`int *p;` `*p = 12;`会出错
7. 传入函数的数组 其实是传入该数组的指针（地址）所以在函数内无法用sizeof来计算数组长度
8. 数组变量本身表达地址 而数组单元（元素）表达的是变量 需要用&来取地址
9. `[]`可以对数组 也可以对指针 而且本身不是数组的变量 通过指针 也可以用`[]`访问
    - 例：`int a = 0;int *p = &a;`所以`p[0] == 0;`
10. `*`运算符也可以对数组名做
11. 数组名本质上是一个常量指针 故而两个数组之间不能直接赋值
12. 指针与const：
    1. const可以修饰指针 也可以修饰被指针指的那个变量
    2. 若const出现在`*`之前 则不可以通过指针解引用来修改指针所指向的变量
        - 例：`const int *p = &a;`则`*p = 100;`会报错 但是`a = 100;`不会
    3. 若const出现在`*`之后 则不可以修改指针所指向的变量
        - 例：`int *const p = &a;`则`p = &b;`会报错
    4. 总是可以将一个非const的值转换成const的
    5. merit：当要传递的参数类型比指针大的时候 常传指针：既可以节省内存 又可以通过const来保证变量不被修改
    6. 注意：const也可以修饰数组
13. 指针运算：指针 + 1 即为指针加上他所指向的那个类型的sizeof
    - char型 p + 1 其地址就加一
    - int型 p + 1 其地址就加四
    - 因此 若是该指针指向的不是一个连续的空间（如单个变量）这个运算就没有意义
14. 指针可以相减：需要两个在连续空间内的指针（如 都指向一个数组 不同元素）
    - 其相减后得到的结果是（地址差 / sizeof）即相差的元素个数
15. 对于*p++：
    - `++`的运算优先级要比`*`高
    - 取出p所指的那个数据 再将指针移到下一位
16. 指针可以作比较（是否相等 谁大谁小）
17. 建议用`NULL`来初始化一个指针
18. 有void类型指针 表示不知道指向何种类型（计算时和char相同 但不相通）
19. 指针可以互相赋值 使另一个指针也指向那个地址
20. 指针可以强转类型（和变量一样）
21. 可以用不同类型的指针指向不同类型的变量 但不安全
22. 总结：指针用处
    1.  需要传入较大的数据来作参数
    2.  传入数组后对数组做操作
    3.  函数返回不止一个结果（如 需要用函数来修改不止一个变量）
    4. 动态申请内存 
23. 关于动态申请内存：
    1.  需要`#include<stdlib.h>`
    2.  malloc函数：申请一块内存（在堆区创建）
        - `int *a = (int*)malloc(n * sizeof(int));`
        - 空间的单位为字节
        - 因为malloc返回的是一个void*类型的 指向一个内存块的指针 所以要强转（也可不强转 会隐式转换）
        - 要把值赋给一个指针
        - 之后就把指针a当作数组来操作就可以了
    3. free函数：把内存还出
       - `free(a);` 
       - 一定是当初申请的那个空间的首地址（故不要对指针进行++这类操作）
       - free完后：
            - 内存中的数据变得未定义
            - 你失去了对这块内存的控制权
            - 任何对该内存的后续访问都是未定义行为，应该避免
            - 记得把当初被赋值那个指针重新定义为NULL（防止悬挂指针）
24. `char** a;`二级指针：指向指针的指针
25. 关于**函数指针**：
    1.  函数指针就是一个指向函数首地址的指针 
    2.  定义：`int (*p)(int, int) = f;`
        - f是函数名 在之前就已定义好的
        - f返回的是int类型 故其指针也是int
        - f有两个int类型的形参
        - 也可以`int (*p)(int, int) = &f;` 不加`&`也会隐式转换
    3. 调用指针：`int a = p(3, 5);` 或 `int a = (*p)(3, 5);` （推荐第二种 让别人可以直接看出这是一个函数指针）
26. 关于二维数组（矩阵）的指针：
    1.  数组名等于数组首地址 也等于数组的[0][0]元素（和一维数组一样）
    2.  行指针：`a + i`是行指针 指向二维数组的第i行（指向一整行）
    3.  列指针：`a[i] + j`是列指针 指向具体的元素（第 i 行第 j 列）
    4.  行列指针的关系：`*(a + i) == a[i] + 0` 即(*行指针)为(列指针)
    5.  指针数组：`int *p[3]` 存放了三个指针的数组
    6.  数组指针：`int (*p)[3]` 一个指向**一个一维数组的**指针 数组长度为3
        - `(*p)`首先说明了p是一个指针 然后才是指向三个int的行
        - 若是p指向了一个二维数组的第0行 可以这样来访问第1行的元素：`p[1][i]`
        - **注意：若p已经指向a的第0行 切不可以为`p[i]`就是访问a的第0行第i列元素 其真实意思是a的第i行的首地址**
        - 个人感觉数组指针类似二维数组
    7. **总结：其实对于数组 数组名所代表的指针就是指向该数组第一个元素 指针类型也和第一个元素一样**
       - *例如二维数组 第一个元素其实是一个一维数组*
### 四、浮点数精度问题
1. float型大约精确到有效数字6~7位 double精确到15~16位
2. 在进行有关浮点数的运算时 要注意精度导致的误差问题
   1. 如要比较两个浮点数的大小 通常不用直接比较 而是转化成两个相减 再与eps比较
   2. eps指的是一个很小的数 大约在1e-12~1e-8之间 但也要根据情况而定
### 五、字符串
1. 字符串是字符数组 以字符数组形态存在
   - `char a[] = {'h','e','l'.'l','o'};`这个不是字符串
   - `char a[] = {'h','e','l'.'l','o','\0'};`这个是字符串 也是一个字符数组
        - `0`或者`'\0'`代表着字符串的结束
        - 计算字符串长度的时候不会包括这个0
        - 注意：若是字符串经过修改 变成类似`he\0llo\0`这种中间有`\0`的 则此字符串就到第一个0处结束 即为`he`
2. 字符串以数组的形式存在 以数组或指针的形式访问（更多以指针的形式）
3. `#include<string.h>`其中有很多处理字符串的函数
4. 定义字符串变量：
   1. `char *str = "hello";`（只读）其实是const char*类型（**指向第一个字符**）
   2. `char a[] = "hello";`
   3. `char a[10] = "hello";`
        - 其中 该字符串占据6个空间（包括结尾的0）
    4. **注意**：不可先`char str[5];` 再`str = "good";`
5. 字符串常量：如`"hello"`
6. 两个相邻的字符串常量会被链接起来
   - 如：`"hello" "world"` -> `"helloworld"`
7. 字符串唯一特殊的地方（区别于数组）就是可以用双引号来初始化字面量（此时就已经区别于普通的字符数组了 自带了末尾0） 以及一些库函数
8. 字符串用指针还是数组：
   - 数组：
        1. 字符串就在此处
        2. 程序结束会被回收
    - 指针：
        1. 字符串不知道在哪里
        2. 处理参数时
        3. 空间是用malloc开辟的时
9. 构造字符串用数组 处理字符串用指针（只读）
10. 读入字符串：用`%xs`其中x为数字 代表最多只读入x个字符
11. 注意：不可定义一个指针（char*）但未初始化 然后用这个指针读入字符串
    - 此为悬空指针 不知道指向哪里 所以容易出错
12. `""`为空字符串
13. `char* a[];`此为存放字符串的数组（只读 因为是指针）**里面是指向字符串的指针**
    1.  `char* s[2] = {"1", "2"};`
    2.  `s[1]` 此为指针 指向 `"2"`
14. **关于`getchar()`和`putchar()`：**
    - `int getchar(void)`：得到一个字符（输入的）若是输入多个字符 则只取第一个
    - `int putchar(int ch)`：输出一个字符
    - 两个函数的返回值都为字符的ASCII码值
    - 若是遇到了文件结束标记（EOF）则返回-1
    - 返回值为int 为了兼容ASCII码和EOF
    - **其中还有很多未明白的细节 留给以后发掘**
15. `string.h`函数：
    1. `size_t strlen(const char* s)`判断字符串有多长（不包括`'\0'`）（若是用sizeof 会把末尾0算进去）
    2. `int strcmp(const char* s1, const char* s2)`对比两个字符串的ASCII码（从第零个开始比较 相同再下一位）
        - 如果两者相同 返回0
        - s1较大 返回1
        - s2较大 返回-1
        - 在有些编译器中 会返回带符号的ASCII码的差值
    3. `char* strcpy(const char* target, const char* source)`复制一段字符串 并且返回其指针
        - 常用复制方法：
        - `char* a = "hello";`
        - `char* b = (char*)malloc(strlen(a) + 1);`
        - `strcpy(b, a);`
        - 注意：malloc需用指针接收 不可用数组
    4. `char *strcat(char *dest, const char *src)`合并两个字符串 将`src`追加到`dest`末尾，要求`dest`有足够的空间容纳结果
    5. `char* strchr(const char* s, int c)`寻找字符串内的ASCII码为c的字符（单个字符） 并返回其指针 若未找到 则返回`NULL`
    6. 还有很多 之后要用到的时候自行查找学习
16. 汉字一个字符占两个字节
17. sizeof计入\0 strlen不计入
18. sprintf函数：格式化转换字符串
```
#include <stdio.h>

int main() {
    int num = 123;
    char str[20];

    sprintf(str, "%d", num);  // 将整数 num 转换成字符串
    printf("字符串是: %s\n", str);

    return 0;
}
```
19. **temp字符串时 常常初始化`{ 0 }`**

