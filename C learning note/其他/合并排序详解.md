好的，我们从 **数组的合并排序** 和 **链表的合并排序** 两部分开始逐步讲解代码实现。让我们分别详细讨论这两个部分。

---

### 1. 数组的合并排序

#### 合并两个已排序的数组

```c
void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;  // 左半部分的长度
    int n2 = right - mid;     // 右半部分的长度

    // 创建临时数组存储左右两部分
    int L[n1], R[n2];

    // 复制数据到临时数组 L 和 R
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i]; // 复制左半部分到 L
    for (int i = 0; i < n2; i++)
        R[i] = arr[mid + 1 + i]; // 复制右半部分到 R

    // 合并两个临时数组
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];  // 如果 L 中的元素小于或等于 R 中的元素
            i++;
        } else {
            arr[k] = R[j];  // 否则，把 R 中的元素放到原数组中
            j++;
        }
        k++;
    }

    // 如果左半部分的元素还有剩余，复制到原数组
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // 如果右半部分的元素还有剩余，复制到原数组
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}
```

**解释：**
- `merge` 函数用于将两个已排序的子数组 `L[]` 和 `R[]` 合并成一个有序数组。
- `left`、`mid`、`right` 是当前排序区间的左边界、分割点和右边界。
- 将原数组 `arr[]` 分割成两个部分：`L[]` 和 `R[]`。
- 然后比较 `L[]` 和 `R[]` 中的元素，将较小的元素逐个放入原数组 `arr[]` 中，保证排序。
- 在最后，若其中一个子数组的元素已经用完，剩余的另一个子数组元素将直接复制到原数组中。

#### 合并排序的递归实现

```c
void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;  // 计算中间点

        // 对左半部分进行合并排序
        mergeSort(arr, left, mid);
        
        // 对右半部分进行合并排序
        mergeSort(arr, mid + 1, right);

        // 合并已排序的两部分
        merge(arr, left, mid, right);
    }
}
```

**解释：**
- `mergeSort` 是合并排序的递归实现。
- 每次递归将数组分割成两部分，直到每部分只包含一个元素。
- `mid` 是计算当前数组分割位置的关键，`mid` 是左半部分的右边界，右半部分从 `mid + 1` 开始。
- 递归调用 `mergeSort` 对每一半进行排序，最后调用 `merge` 函数将左右两半合并。

#### 打印数组

```c
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}
```

**解释：**
- 这是一个辅助函数，用于打印数组的元素。

#### 主函数

```c
int main() {
    int arr[] = {12, 11, 13, 5, 6, 7};
    int arr_size = sizeof(arr) / sizeof(arr[0]);

    printf("Original array: ");
    printArray(arr, arr_size);

    // 对数组进行合并排序
    mergeSort(arr, 0, arr_size - 1);

    printf("Sorted array: ");
    printArray(arr, arr_size);

    return 0;
}
```

**解释：**
- 在 `main` 函数中，首先创建了一个数组 `arr[]`，并打印原始数组。
- 然后调用 `mergeSort` 函数对数组进行排序。
- 最后打印排序后的数组。

---

### 2. 链表的合并排序

对于链表，合并排序的思路基本相同，但实现方式有所不同，主要在于链表结构的操作。

#### 合并两个已排序的链表

```c
struct Node* merge(struct Node* left, struct Node* right) {
    if (!left) return right;
    if (!right) return left;

    struct Node* result = NULL;
    if (left->data < right->data) {
        result = left;
        result->next = merge(left->next, right);
    } else {
        result = right;
        result->next = merge(left, right->next);
    }
    return result;
}
```

**解释：**
- `merge` 函数用于合并两个已排序的链表 `left` 和 `right`。
- 通过递归比较两个链表的 `data`，每次将较小的元素连接到合并链表 `result` 上。
- 如果其中一个链表为空，直接返回另一个链表。

#### 查找链表中间节点

```c
struct Node* findMiddle(struct Node* head) {
    if (!head) return head;

    struct Node* slow = head;
    struct Node* fast = head->next;

    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}
```

**解释：**
- `findMiddle` 函数使用快慢指针法找到链表的中间节点。
  - `slow` 指针每次走一步，`fast` 指针每次走两步。
  - 当 `fast` 指针到达链表末尾时，`slow` 指针就指向链表的中间节点。

#### 合并排序链表

```c
struct Node* mergeSort(struct Node* head) {
    if (!head || !head->next) return head;

    // 找到链表的中间节点并分割链表
    struct Node* mid = findMiddle(head);
    struct Node* left = head;
    struct Node* right = mid->next;
    mid->next = NULL;

    // 递归地对两部分进行排序
    left = mergeSort(left);
    right = mergeSort(right);

    // 合并已排序的两部分
    return merge(left, right);
}
```

**解释：**
- `mergeSort` 是链表的合并排序的递归实现。
- 先使用 `findMiddle` 函数找到链表的中间节点。
- 将链表分为两部分：左半部分 `left` 和右半部分 `right`。
- 递归地对这两部分进行排序，然后将已排序的两部分合并。

#### 打印链表

```c
void printList(struct Node* head) {
    struct Node* temp = head;
    while (temp) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}
```

**解释：**
- 这个函数用来遍历并打印链表，显示每个节点的数据，直到链表末尾。

#### 插入新节点到链表头部

```c
void push(struct Node** head_ref, int new_data) {
    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = (*head_ref);
    (*head_ref) = new_node;
}
```

**解释：**
- 这是一个辅助函数，用于将新节点插入到链表的头部。

#### 主函数

```c
int main() {
    struct Node* head = NULL;

    // 创建链表：5 -> 3 -> 9 -> 1 -> NULL
    push(&head, 5);
    push(&head, 3);
    push(&head, 9);
    push(&head, 1);

    printf("Original linked list: ");
    printList(head);

    // 对链表进行合并排序
    head = mergeSort(head);

    printf("Sorted linked list: ");
    printList(head);

    return 0;
}
```

**解释：**
- 在 `main` 函数中，首先创建一个链表并打印原始链表。
- 然后调用 `mergeSort` 函数对链表进行排序。
- 最后打印排序后的链表。

---

### 总结

- **数组的合并排序**：通过递归将数组分割成两部分，每一部分排序后

合并。通过比较两部分的元素，保证合并后的数组仍然有序。
- **链表的合并排序**：和数组类似，递归地分割链表，排序后合并。链表的合并操作通过修改指针实现，不需要额外的空间。