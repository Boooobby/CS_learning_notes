# 链表
在 C 中，**链表**是一种基本的数据结构，用于动态存储和操作数据。链表是通过节点（`node`）及其指针将多个元素链接在一起的结构。它适合需要频繁插入和删除操作的场景，因为这些操作在链表中比数组更高效（无需移动元素）。

---

## **1. 链表的基本概念**

### **1.1 单向链表（Singly Linked List）**
- 每个节点包含两个部分：
  1. **数据部分**：存储具体的数据。
  2. **指针部分**：存储指向下一个节点的指针。
- 最后一个节点的指针为 `NULL`。

```c
struct Node {
    int data;            // 数据部分
    struct Node* next;   // 指针部分，指向下一个节点
};
```

---

### **1.2 双向链表（Doubly Linked List）**
- 每个节点包含三个部分：
  1. **数据部分**：存储数据。
  2. **前向指针**：指向前一个节点。
  3. **后向指针**：指向下一个节点。
- 链表可以双向遍历。

```c
struct Node {
    int data;             // 数据部分
    struct Node* prev;    // 指向前一个节点
    struct Node* next;    // 指向下一个节点
};
```

---

## **2. 单向链表的实现**

### **2.1 创建节点**
创建一个新的链表节点：

```c
#include <stdio.h>
#include <stdlib.h>

// 定义链表节点结构
struct Node {
    int data;
    struct Node* next;
};

// 创建新节点函数
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (!newNode) {
        printf("内存分配失败！\n");
        exit(1);
    }
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}
```

---

### **2.2 插入操作**
#### **在链表头部插入节点**
```c
struct Node* insertAtHead(struct Node* head, int data) {
    struct Node* newNode = createNode(data);
    newNode->next = head;
    return newNode; // 新节点成为新的头节点
}
```

#### **在链表尾部插入节点**
```c
struct Node* insertAtTail(struct Node* head, int data) {
    struct Node* newNode = createNode(data);
    if (!head) return newNode; // 链表为空，直接返回新节点

    struct Node* temp = head;
    while (temp->next) {
        temp = temp->next;
    }
    temp->next = newNode;
    return head; // 返回原头节点
}
```

---

### **2.3 删除操作**
#### **删除链表中的某个节点**
```c
struct Node* deleteNode(struct Node* head, int key) {
    if (!head) return NULL; // 链表为空

    // 如果删除的是头节点
    if (head->data == key) {
        struct Node* temp = head;
        head = head->next;
        free(temp);
        return head;
    }

    // 查找需要删除的节点
    struct Node* current = head;
    struct Node* prev = NULL;

    while (current && current->data != key) {
        prev = current;
        current = current->next;
    }

    if (current) {
        prev->next = current->next;
        free(current);
    }

    return head;
}
```

---

### **2.4 遍历链表**
```c
void printList(struct Node* head) {
    struct Node* temp = head;
    while (temp) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}
```

---

### **2.5 释放链表内存**
```c
void freeList(struct Node* head) {
    struct Node* temp;
    while (head) {
        temp = head;
        head = head->next;
        free(temp);
    }
}
```

---

### **2.6 综合示例代码**

以下是一个完整的单向链表实现示例：
```c
#include <stdio.h>
#include <stdlib.h>

// 链表节点结构
struct Node {
    int data;
    struct Node* next;
};

// 创建新节点
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (!newNode) {
        printf("内存分配失败！\n");
        exit(1);
    }
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// 头部插入
struct Node* insertAtHead(struct Node* head, int data) {
    struct Node* newNode = createNode(data);
    newNode->next = head;
    return newNode;
}

// 尾部插入
struct Node* insertAtTail(struct Node* head, int data) {
    struct Node* newNode = createNode(data);
    if (!head) return newNode;

    struct Node* temp = head;
    while (temp->next) {
        temp = temp->next;
    }
    temp->next = newNode;
    return head;
}

// 删除节点
struct Node* deleteNode(struct Node* head, int key) {
    if (!head) return NULL;

    if (head->data == key) {
        struct Node* temp = head;
        head = head->next;
        free(temp);
        return head;
    }

    struct Node* current = head;
    struct Node* prev = NULL;

    while (current && current->data != key) {
        prev = current;
        current = current->next;
    }

    if (current) {
        prev->next = current->next;
        free(current);
    }

    return head;
}

// 打印链表
void printList(struct Node* head) {
    struct Node* temp = head;
    while (temp) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// 释放链表内存
void freeList(struct Node* head) {
    struct Node* temp;
    while (head) {
        temp = head;
        head = head->next;
        free(temp);
    }
}

// 主函数
int main() {
    struct Node* head = NULL;

    // 插入操作
    head = insertAtHead(head, 1);
    head = insertAtTail(head, 2);
    head = insertAtTail(head, 3);

    // 打印链表
    printf("链表内容：\n");
    printList(head);

    // 删除节点
    head = deleteNode(head, 2);
    printf("删除节点后：\n");
    printList(head);

    // 释放内存
    freeList(head);

    return 0;
}
```

---

## **3. 总结**
- 链表的特点是 **动态内存分配** 和 **高效的插入删除**。
- 单向链表适合需要从头到尾顺序遍历的场景。
- 双向链表则更适合需要前后遍历的场景，代价是每个节点需要更多内存。
- 在使用链表时，需注意内存管理，及时释放不再使用的节点，以避免内存泄漏。