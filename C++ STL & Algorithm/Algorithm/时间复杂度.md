递归的时间复杂度分析是计算程序在递归调用中执行操作的总数量。为了准确分析递归的时间复杂度，需要理解递归调用的结构及每次调用的工作量。

### **递归时间复杂度分析步骤**

1. **写出递归函数的执行公式**  
   根据递归函数的定义，建立递归关系式，描述递归调用的次数和每次调用的操作量。

2. **解递归关系式**  
   使用展开法或主定理（Master Theorem）来求解递归关系式。

3. **得出时间复杂度**  
   根据最终公式判断大 \(O\) 时间复杂度。

---

### **常见递归分析方法**

#### **1. 展开法**

通过展开递归调用，将递归关系式展开到基本情况，观察递归的层数和每层的工作量，累加得到总复杂度。

**示例 1：简单线性递归**
```c
int sum(int n) {
    if (n == 1) return 1;      // 基本情况
    return n + sum(n - 1);     // 递归调用
}
```
递归关系式：  
\[
T(n) = T(n-1) + O(1)
\]

展开递归：  
\[
T(n) = T(n-1) + O(1) = T(n-2) + O(1) + O(1) = \dots = T(1) + n \cdot O(1)
\]

结果：  
\[
T(n) = O(n)
\]

**总结：**  
- 每次递归调用的工作量为 \(O(1)\)，递归深度为 \(n\)，总复杂度为 \(O(n)\)。

---

#### **2. 树状递归**

树状递归表示每次递归调用会生成多个子问题，类似树的结构。需要计算递归树的深度和每层的总工作量。

**示例 2：二分递归**
```c
int fib(int n) {
    if (n <= 1) return n;       // 基本情况
    return fib(n - 1) + fib(n - 2); // 递归调用
}
```

递归关系式：  
\[
T(n) = T(n-1) + T(n-2) + O(1)
\]

**分析：**  
- 递归树的深度为 \(n\)。
- 每层的节点数量大致为斐波那契数列增长。
- 总体递归调用次数接近 \(2^n\)。

结果：  
\[
T(n) = O(2^n)
\]

**总结：**  
- 树状递归可能导致指数增长，效率较低。

---

#### **3. 主定理（Master Theorem）**

主定理用于解决形如以下形式的递归关系式：  
\[
T(n) = aT\left(\frac{n}{b}\right) + O(n^d)
\]
其中：
- \(a\)：每次递归生成的子问题数；
- \(b\)：每次递归将问题规模缩小的比例；
- \(O(n^d)\)：每次递归调用的额外工作量。

**主定理规则：**
- 如果 \(d < \log_b a\)，则 \(T(n) = O(n^{\log_b a})\)。
- 如果 \(d = \log_b a\)，则 \(T(n) = O(n^d \log n)\)。
- 如果 \(d > \log_b a\)，则 \(T(n) = O(n^d)\)。

**示例 3：分治算法**
```c
void mergeSort(int arr[], int n) {
    if (n < 2) return;
    int mid = n / 2;
    mergeSort(arr, mid);           // 左半部分
    mergeSort(arr + mid, n - mid); // 右半部分
    merge(arr, mid, n - mid);      // 合并
}
```

递归关系式：  
\[
T(n) = 2T\left(\frac{n}{2}\right) + O(n)
\]

分析：  
- \(a = 2\)，\(b = 2\)，\(d = 1\)（合并操作为 \(O(n)\)）。
- \(\log_b a = \log_2 2 = 1\)。

结果：  
- \(d = \log_b a\)，适用第二种情况，复杂度为 \(O(n \log n)\)。

---

### **递归时间复杂度总结表**

| 递归形式                     | 关系式                                | 时间复杂度    |
|------------------------------|---------------------------------------|--------------|
| 简单线性递归                | \(T(n) = T(n-1) + O(1)\)              | \(O(n)\)     |
| 树状递归（斐波那契数列）    | \(T(n) = T(n-1) + T(n-2) + O(1)\)     | \(O(2^n)\)   |
| 分治递归（平衡分割）        | \(T(n) = 2T(n/2) + O(n)\)             | \(O(n \log n)\) |
| 分治递归（不平衡分割）      | \(T(n) = T(n-1) + O(1)\)              | \(O(n)\)     |
| 二分查找                   | \(T(n) = T(n/2) + O(1)\)              | \(O(\log n)\)|

---

通过这些方法，你可以系统地分析各种递归问题的时间复杂度。如果有具体代码或递归关系式，欢迎提供，我们可以一起详细分析！