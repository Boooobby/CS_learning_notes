## **快速幂算法详解**

快速幂算法是一种高效计算 \( a^b \mod m \) 的算法，尤其在 \( b \) 很大时表现优越。它利用了指数的二进制表示，将时间复杂度从 \( O(b) \) 降低到 \( O(\log b) \)。

---

### **核心思想**
快速幂的核心在于 **分治法** 和 **模运算结合律**。通过将指数分解为二进制形式，我们可以避免逐次乘法操作，快速得出结果。

#### **数学基础**
任何一个指数 \( b \) 都可以用二进制表示：
\[
b = b_k \cdot 2^k + b_{k-1} \cdot 2^{k-1} + \dots + b_0 \cdot 2^0
\]
其中 \( b_i \in \{0, 1\} \)。

因此：
\[
a^b = a^{b_k \cdot 2^k} \cdot a^{b_{k-1} \cdot 2^{k-1}} \cdots a^{b_0 \cdot 2^0}
\]

使用这一性质，指数的每一位对应一个幂次方运算。我们从低到高逐步计算 \( a^{2^i} \)，并将结果累乘到最终答案中。

---

### **算法步骤**
#### 输入：底数 \( a \)、指数 \( b \)、模数 \( m \)
#### 输出：\( a^b \mod m \)

1. **初始化**：
   - 结果 \( res = 1 \)，表示当前乘积的中间结果。
   - 基数 \( base = a \mod m \)，防止初始 \( a \) 过大。

2. **迭代**：
   - 如果当前指数的最低位（\( b \% 2 \)）是 1，则累乘当前基数 \( base \)：
     \[
     res = (res \cdot base) \mod m
     \]
   - 更新基数为 \( base^2 \mod m \)（平方基数）。
   - 指数右移一位（\( b = b / 2 \)），相当于去掉最低位。

3. **终止条件**：
   - 当指数 \( b = 0 \) 时，停止循环。

---

### **代码实现**
以下是快速幂的完整代码实现：

#### **递归实现**
递归实现利用函数调用，直观地体现了分治思想。

```cpp
long long modExpRecursive(long long base, long long exp, long long mod) {
    if (exp == 0) return 1;  // 指数为 0 时，任何数的 0 次方为 1
    long long half = modExpRecursive(base, exp / 2, mod);
    half = (half * half) % mod;  // 平方结果
    if (exp % 2 != 0) {  // 如果指数是奇数
        half = (half * base) % mod;
    }
    return half;
}
```

#### **迭代实现**
迭代实现更高效，因为它避免了递归的函数调用开销。

```cpp
long long modExpIterative(long long base, long long exp, long long mod) {
    long long result = 1;
    base = base % mod;  // 预处理，防止 base 过大

    while (exp > 0) {
        if (exp % 2 == 1) {  // 如果当前指数最低位是 1
            result = (result * base) % mod;
        }
        base = (base * base) % mod;  // 平方基数
        exp = exp / 2;  // 指数右移一位
    }
    return result;
}
```

---

### **例子解析**
#### 计算 \( 2^{13} \mod 1000 \)
1. **初始化**：
   - \( base = 2 \), \( exp = 13 \), \( mod = 1000 \)
   - \( result = 1 \)

2. **迭代过程**：
   - **第 1 步**：
     - \( exp = 13 \)（二进制 \( 1101 \)，最低位是 1）
     - \( result = (1 \cdot 2) \mod 1000 = 2 \)
     - \( base = (2 \cdot 2) \mod 1000 = 4 \)
     - \( exp = 13 / 2 = 6 \)
   - **第 2 步**：
     - \( exp = 6 \)（二进制 \( 110 \)，最低位是 0）
     - 不更新 \( result \)
     - \( base = (4 \cdot 4) \mod 1000 = 16 \)
     - \( exp = 6 / 2 = 3 \)
   - **第 3 步**：
     - \( exp = 3 \)（二进制 \( 11 \)，最低位是 1）
     - \( result = (2 \cdot 16) \mod 1000 = 32 \)
     - \( base = (16 \cdot 16) \mod 1000 = 256 \)
     - \( exp = 3 / 2 = 1 \)
   - **第 4 步**：
     - \( exp = 1 \)（二进制 \( 1 \)，最低位是 1）
     - \( result = (32 \cdot 256) \mod 1000 = 192 \)
     - \( base = (256 \cdot 256) \mod 1000 = 536 \)
     - \( exp = 1 / 2 = 0 \)

3. **最终结果**：
   \[
   result = 192
   \]

---

### **复杂度分析**
1. **时间复杂度**：
   - 指数每次减半，循环最多执行 \( \log_2(b) \) 次。
   - 每次操作为常数时间，整体复杂度为 \( O(\log b) \)。

2. **空间复杂度**：
   - **递归实现**需要 \( O(\log b) \) 的递归栈空间。
   - **迭代实现**只需要 \( O(1) \) 的额外空间。

---

### **快速幂优势**
- 能高效处理指数 \( b \) 很大的情况。
- 模运算结合律保证了中间结果不会溢出。
- 广泛应用于加密算法（如 RSA）、大数运算等领域。

---

### **应用场景**
1. 计算 \( 2^n \mod (10^9 + 7) \)。
2. 处理离散数学问题中的指数增长。
3. 优化涉及幂运算的复杂计算。