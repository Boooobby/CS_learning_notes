# 深入理解C++中的`std::unordered_set`

`std::unordered_set`是C++11引入的哈希集合容器，与`std::set`相比有显著不同的特性和适用场景。下面我将全面介绍它的工作原理、使用方法和最佳实践。

## 基本特性

1. **无序存储**：元素不按特定顺序排列（与插入顺序无关）
2. **唯一性**：所有元素都是唯一的（不允许重复）
3. **实现方式**：基于哈希表实现
4. **头文件**：`#include <unordered_set>`
5. **时间复杂度**：
   - 平均情况：插入/删除/查找 O(1)
   - 最坏情况：O(n)（当哈希冲突严重时）

## 基本操作

### 创建unordered_set

```cpp
std::unordered_set<int> us1; // 空unordered_set
std::unordered_set<int> us2 = {1, 2, 3, 4}; // 初始化列表
std::unordered_set<int> us3(us2.begin(), us2.end()); // 通过迭代器范围构造
std::unordered_set<int> us4(us3); // 拷贝构造
```

### 插入元素

```cpp
std::unordered_set<std::string> us;
us.insert("apple"); // 插入单个元素
us.insert({"banana", "cherry"}); // 插入多个元素
auto [iter, success] = us.insert("apple"); // C++17结构化绑定，success为false
```

### 删除元素

```cpp
us.erase("banana"); // 删除值为"banana"的元素
us.erase(us.begin()); // 删除第一个元素（顺序不确定）
us.erase(us.begin(), us.end()); // 删除所有元素
us.clear(); // 清空unordered_set
```

### 查找元素

```cpp
auto it = us.find("apple"); // 返回迭代器，找不到返回us.end()
if (us.count("cherry") > 0) { // 返回1(存在)或0(不存在)
    // 元素存在
}
// C++20新增
if (us.contains("apple")) { // 更直观的检查方法
    // 元素存在
}
```

## 哈希相关特性

### 自定义哈希函数

```cpp
struct MyHash {
    size_t operator()(const std::string& s) const {
        return s.length(); // 简单示例：按字符串长度哈希
    }
};

std::unordered_set<std::string, MyHash> custom_hash_set;
```

### 自定义相等比较

```cpp
struct CaseInsensitiveEqual {
    bool operator()(const std::string& a, const std::string& b) const {
        return strcasecmp(a.c_str(), b.c_str()) == 0;
    }
};

std::unordered_set<std::string, 
                  std::hash<std::string>, 
                  CaseInsensitiveEqual> case_insensitive_set;
```

### 哈希策略控制

```cpp
std::unordered_set<int> us;
us.reserve(100); // 预分配空间，减少rehash
std::cout << "Load factor: " << us.load_factor() << "\n"; // 当前负载因子
us.max_load_factor(0.7); // 设置最大负载因子
us.rehash(50); // 强制rehash
```

## 性能特点

1. **优势**：
   - 平均情况下常数时间访问
   - 插入和删除效率高
   - 不需要维护元素顺序，开销小

2. **劣势**：
   - 最坏情况下性能退化
   - 迭代顺序不确定
   - 内存使用通常高于`std::set`

## 与`std::set`的对比

| 特性                | std::unordered_set       | std::set               |
|---------------------|-------------------------|-----------------------|
| **实现方式**         | 哈希表                  | 红黑树                |
| **元素顺序**         | 无序                    | 有序                  |
| **查找时间复杂度**   | 平均O(1)，最差O(n)      | O(log n)              |
| **插入时间复杂度**   | 平均O(1)，最差O(n)      | O(log n)              |
| **内存使用**         | 通常较高                | 通常较低              |
| **适用场景**         | 快速查找，不关心顺序     | 需要有序或范围查询     |

## 实际应用示例

### 统计唯一单词

```cpp
std::unordered_set<std::string> word_set;
std::string word;
while (std::cin >> word) {
    word_set.insert(word);
}
std::cout << "Unique words: " << word_set.size() << "\n";
```

### 快速查找表

```cpp
std::unordered_set<int> prime_cache = {2, 3, 5, 7, 11, 13, 17, 19};

bool is_prime(int n) {
    return prime_cache.find(n) != prime_cache.end();
}
```

## 最佳实践

1. **预分配空间**：如果知道元素数量，使用`reserve()`减少rehash
2. **自定义类型**：必须提供哈希函数和相等比较
3. **性能敏感场景**：监控负载因子，适时rehash
4. **避免频繁插入删除**：批量操作更高效
5. **C++20优化**：优先使用`contains()`而非`find()`

## 自定义类型使用示例

```cpp
struct Point {
    int x, y;
    bool operator==(const Point& p) const {
        return x == p.x && y == p.y;
    }
};

struct PointHash {
    size_t operator()(const Point& p) const {
        return std::hash<int>()(p.x) ^ std::hash<int>()(p.y);
    }
};

std::unordered_set<Point, PointHash> point_set;
point_set.insert({1, 2});
```

`std::unordered_set`是处理需要快速查找且不关心元素顺序场景的理想选择，合理使用可以显著提升程序性能。