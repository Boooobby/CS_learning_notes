# C++中的Vector详细学习指南

`std::vector`是C++标准模板库(STL)中最重要和最常用的容器之一，它提供了动态数组的功能。下面我将全面介绍vector的各个方面。

## 1. Vector基本概念

### 什么是vector?
- 动态数组，可以在运行时动态改变大小
- 存储在连续的内存空间中
- 提供随机访问迭代器
- 属于序列式容器

### 基本特性
- **动态大小**：自动处理内存分配和释放
- **快速访问**：O(1)时间复杂度访问任意元素
- **尾部高效**：在末尾插入/删除元素效率高(O(1))
- **中部/头部低效**：在中间或开头插入/删除元素效率低(O(n))

## 2. Vector的声明和初始化

### 包含头文件
```cpp
#include <vector>
```

### 声明方式
```cpp
std::vector<int> v1;             // 空vector
std::vector<int> v2(5);          // 5个元素，默认值为0
std::vector<int> v3(5, 10);      // 5个元素，每个都是10
std::vector<int> v4{1, 2, 3};    // 初始化列表
std::vector<int> v5(v4);         // 拷贝构造
std::vector<int> v6(v5.begin(), v5.end()); // 通过迭代器范围构造
```

## 3. Vector的基本操作

### 访问元素
```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

// 使用下标访问(不检查边界)
int a = vec[2]; 

// 使用at()访问(检查边界，越界抛出异常)
int b = vec.at(3); 

// 访问第一个和最后一个元素
int first = vec.front(); 
int last = vec.back(); 

// 使用迭代器访问
for (auto it = vec.begin(); it != vec.end(); ++it) {
    std::cout << *it << " ";
}
```

### 添加元素
```cpp
vec.push_back(6);       // 在末尾添加元素
vec.emplace_back(7);    // 更高效的末尾添加(C++11)

vec.insert(vec.begin() + 2, 10); // 在指定位置插入元素
vec.emplace(vec.begin() + 1, 20); // 更高效的插入(C++11)
```

### 删除元素
```cpp
vec.pop_back();         // 删除最后一个元素

vec.erase(vec.begin() + 1); // 删除指定位置元素
vec.erase(vec.begin(), vec.begin() + 2); // 删除范围

vec.clear();            // 清空所有元素
```

## 4. Vector的容量操作

```cpp
std::vector<int> vec;

// 当前元素数量
size_t size = vec.size();

// 是否为空
bool empty = vec.empty();

// 当前容量(已分配内存可存储的元素数量)
size_t cap = vec.capacity();

// 改变容量
vec.reserve(100);       // 预留空间，避免多次重新分配

// 改变大小
vec.resize(10);         // 调整为10个元素，新增元素默认初始化
vec.resize(15, 5);      // 调整为15个元素，新增元素初始化为5
```

## 5. Vector的迭代器

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

// 正向迭代器
for (auto it = vec.begin(); it != vec.end(); ++it) {
    std::cout << *it << " ";
}

// 反向迭代器
for (auto rit = vec.rbegin(); rit != vec.rend(); ++rit) {
    std::cout << *rit << " ";
}

// 常量迭代器
for (auto cit = vec.cbegin(); cit != vec.cend(); ++cit) {
    // *cit = 10; // 错误，不能修改
    std::cout << *cit << " ";
}
```

## 6. Vector的内存管理

### 内存分配策略
- 当当前容量不足时，vector会分配更大的内存块(通常是当前容量的2倍)
- 然后将所有元素从旧内存复制到新内存
- 最后释放旧内存

### 性能考虑
- 频繁的重新分配会影响性能
- 如果知道最终大小，应预先使用reserve()

```cpp
std::vector<int> vec;
vec.reserve(1000); // 预先分配足够空间
for (int i = 0; i < 1000; ++i) {
    vec.push_back(i); // 不会触发重新分配
}
```

## 7. Vector的高级用法

### 交换两个vector
```cpp
std::vector<int> v1{1, 2, 3};
std::vector<int> v2{4, 5, 6};
v1.swap(v2); // 交换内容
```

### 移动语义(C++11)
```cpp
std::vector<int> createVector() {
    std::vector<int> temp{1, 2, 3};
    return temp; // 触发移动语义
}

std::vector<int> v = createVector(); // 高效，不复制
```

### 使用自定义分配器
```cpp
#include <memory>
std::vector<int, std::allocator<int>> v; // 使用自定义分配器
```

## 8. Vector的常见算法

结合STL算法使用vector:

```cpp
#include <algorithm>

std::vector<int> vec = {5, 3, 1, 4, 2};

// 排序
std::sort(vec.begin(), vec.end());

// 查找
auto it = std::find(vec.begin(), vec.end(), 3);

// 反转
std::reverse(vec.begin(), vec.end());

// 累加
int sum = std::accumulate(vec.begin(), vec.end(), 0);
```

## 9. Vector的性能分析

| 操作 | 时间复杂度 |
|------|-----------|
| 随机访问 | O(1) |
| 尾部插入/删除 | O(1) |
| 头部/中部插入/删除 | O(n) |
| 查找 | O(n) |
| 排序 | O(n log n) |

## 10. Vector的常见错误

1. **越界访问**：
   ```cpp
   std::vector<int> v{1, 2, 3};
   int x = v[5]; // 未定义行为
   ```

2. **迭代器失效**：
   ```cpp
   std::vector<int> v{1, 2, 3};
   auto it = v.begin();
   v.push_back(4); // 可能导致迭代器失效
   *it = 10;       // 危险!
   ```

3. **误用size_type和int**：
   ```cpp
   for (int i = 0; i < v.size(); ++i) // 当size() > INT_MAX时有问题
   ```

## 11. Vector的最佳实践

1. 优先使用emplace_back()而非push_back()
2. 预先使用reserve()分配足够空间
3. 遍历时优先使用范围for循环(C++11)
   ```cpp
   for (const auto& elem : vec) {
       std::cout << elem << " ";
   }
   ```
4. 避免在循环中频繁插入/删除
5. 考虑使用data()获取原始指针(C++11)
   ```cpp
   int* p = vec.data();
   ```

## 12. Vector与其他容器的比较

| 特性 | vector | deque | list | array |
|------|--------|-------|------|-------|
| 动态大小 | 是 | 是 | 是 | 否 |
| 随机访问 | 是 | 是 | 否 | 是 |
| 头部插入效率 | 低 | 高 | 高 | - |
| 中部插入效率 | 低 | 低 | 高 | - |
| 尾部插入效率 | 高 | 高 | 高 | - |
| 内存连续性 | 是 | 部分 | 否 | 是 |

## 总结

`std::vector`是C++中最通用和高效的容器之一，适用于大多数需要动态数组的场景。理解其内部工作原理和性能特征对于编写高效的C++代码至关重要。通过合理使用reserve()、emplace_back()等特性，可以最大限度地发挥vector的性能优势。