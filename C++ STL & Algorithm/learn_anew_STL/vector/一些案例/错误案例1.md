```cpp
#include <iostream>
#include <vector>

using namespace std;

int main()
{
	vector<int> v;
	v.reserve(1000);

	int* p = v.data();
	*p = 1;

	auto it = v.begin();

	for (auto i : v)
	{
		cout << i << endl;
		cout << *it << endl;
	}

	return 0;
}
```
## 代码分析：为什么不会输出1

您提供的代码不会输出 `1` 的原因与 `vector` 的内存管理和迭代器有效性规则有关。让我们逐步分析：

### 关键问题点

1. **`reserve()` 与 `size()` 的区别**：
   - `reserve(1000)` 只分配内存，**不改变** vector 的 `size()`
   - 您的 vector 仍然是**空的**（`size() == 0`），尽管它有容量

2. **`data()` 指针操作的危险性**：
   - 您通过 `data()` 获取指针并写入 `*p = 1`，这实际上是**未定义行为(UB)**
   - 虽然可能写入成功，但没有改变 vector 的正式大小

3. **迭代器失效**：
   - `begin()` 返回的迭代器指向的是 `size()` 范围内的第一个元素
   - 由于 `size() == 0`，`begin() == end()`，解引用 `*it` 是未定义行为

4. **范围for循环**：
   - `for (auto i : v)` 基于 `begin()`/`end()`，因为 `size()==0`，循环体**根本不会执行**

### 正确的修改方式

如果您想预先分配内存然后添加元素，应该：

```cpp
vector<int> v;
v.reserve(1000);  // 仅分配内存

// 正确添加元素的方式
v.push_back(1);   // 现在 size() == 1

// 或者使用resize
// v.resize(1000); // size() == 1000
// v[0] = 1;      // 合法操作
```

### 为什么您的代码不会崩溃（但也不输出）

虽然代码有未定义行为，但可能不会立即崩溃的原因是：
1. `reserve()` 确实分配了内存，所以 `*p = 1` 可能写入了合法内存
2. 但 vector 的元数据仍然认为它没有元素
3. 范围for循环看到 `size()==0` 直接跳过

### 关键教训

1. `reserve()` ≠ `resize()`：
   - `reserve()`：只影响容量(capacity)
   - `resize()`：改变大小(size)并初始化元素

2. 永远不要通过 `data()` 直接修改超出 `size()` 范围的元素

3. 迭代器的有效性始终与 `size()` 相关，而不是 `capacity()`

4. 未定义行为可能"看似工作"，但绝对不能依赖这种行为

### 正确使用 `data()` 的例子

```cpp
vector<int> v(10); // size=10, capacity>=10
int* p = v.data();
p[0] = 1;          // 合法，因为size=10

for (auto i : v) {
    cout << i << endl; // 会输出1和其他9个0
}
```

总结：您的代码没有输出是因为 vector 仍然是空的（`size()==0`），尽管您通过指针技巧写入了内存。这是典型的未定义行为案例，应该避免。
