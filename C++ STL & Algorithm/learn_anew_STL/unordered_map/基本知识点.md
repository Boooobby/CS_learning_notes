# 深入详解 unordered_map 的基本操作

作为 C++ 中基于哈希表的关联容器，`unordered_map` 的基本操作是使用它的关键。下面我将非常详细地讲解每个基本操作，包括各种使用场景和注意事项。

## 1. 创建和初始化 unordered_map

### 1.1 空容器构造

```cpp
#include <unordered_map>
#include <string>

// 创建一个键为string，值为int的空unordered_map
std::unordered_map<std::string, int> word_count;

// 可以指定初始桶的数量（提高性能）
std::unordered_map<std::string, int> word_count2(100);  // 初始100个桶
```

### 1.2 使用初始化列表构造

```cpp
// 使用花括号初始化
std::unordered_map<std::string, int> word_count = {
    {"apple", 5},    // 键值对1
    {"banana", 3},   // 键值对2
    {"orange", 8}    // 键值对3
};

// 也可以这样写
std::unordered_map<std::string, int> word_count2 {
    {"apple", 5},
    {"banana", 3},
    {"orange", 8}
};
```

### 1.3 复制构造

```cpp
// 从另一个unordered_map复制
std::unordered_map<std::string, int> word_count_copy(word_count);

// 也可以使用赋值操作符
std::unordered_map<std::string, int> another_copy;
another_copy = word_count;
```

## 2. 插入元素操作

### 2.1 使用 insert 方法

```cpp
// 插入单个元素
auto ret = word_count.insert({"pear", 4});

// ret是一个pair，包含一个迭代器和一个bool值
// ret.first 是指向插入元素的迭代器
// ret.second 表示是否插入成功（false表示键已存在）
if (ret.second) {
    std::cout << "插入成功" << std::endl;
} else {
    std::cout << "键已存在" << std::endl;
}

// 也可以这样插入
word_count.insert(std::make_pair("grape", 7));
```

### 2.2 使用 emplace 方法（更高效）

```cpp
// 直接在容器内构造元素，避免临时对象
auto ret = word_count.emplace("melon", 9);

// 等同于 insert({"melon", 9})，但更高效
// ret也是一个pair，与insert相同
```

### 2.3 使用下标操作符 []

```cpp
// 如果键不存在，会自动创建并值初始化
word_count["kiwi"] = 2;  // 插入"kiwi"并设置值为2

// 如果键已存在，会覆盖原有值
word_count["apple"] = 10;  // 修改apple的值为10

// 注意：使用[]访问不存在的键会自动插入！
int val = word_count["mango"];  // 如果mango不存在，会插入mango并值初始化为0
```

### 2.4 批量插入

```cpp
std::unordered_map<std::string, int> more_fruits = {
    {"peach", 3},
    {"plum", 6}
};

word_count.insert(more_fruits.begin(), more_fruits.end());
```

## 3. 访问元素操作

### 3.1 使用 at 方法（安全访问）

```cpp
try {
    // at方法在键不存在时会抛出std::out_of_range异常
    int count = word_count.at("apple");
    std::cout << "apple count: " << count << std::endl;
} catch (const std::out_of_range& e) {
    std::cerr << "键不存在: " << e.what() << std::endl;
}
```

### 3.2 使用 find 方法（推荐方式）

```cpp
// find返回一个迭代器
auto it = word_count.find("banana");

if (it != word_count.end()) {
    // it->first 是键
    // it->second 是值
    std::cout << "找到: " << it->first << " => " << it->second << std::endl;
} else {
    std::cout << "未找到" << std::endl;
}
```

### 3.3 使用 count 方法检查存在性

```cpp
// count返回键存在的次数（对于unordered_map只能是0或1）
if (word_count.count("orange") > 0) {
    std::cout << "orange存在" << std::endl;
} else {
    std::cout << "orange不存在" << std::endl;
}
```

## 4. 修改元素操作

### 4.1 通过迭代器修改

```cpp
auto it = word_count.find("apple");
if (it != word_count.end()) {
    it->second = 15;  // 修改值
    // it->first = "new_apple";  // 错误！不能修改键
}
```

### 4.2 使用 insert_or_assign (C++17)

```cpp
// 如果键存在则修改，不存在则插入
auto [iter, inserted] = word_count.insert_or_assign("apple", 20);
if (inserted) {
    std::cout << "插入新元素" << std::endl;
} else {
    std::cout << "修改已存在元素" << std::endl;
}
```

## 5. 删除元素操作

### 5.1 通过键删除

```cpp
// 返回删除的元素数量（对于unordered_map是0或1）
size_t num_erased = word_count.erase("apple");

if (num_erased > 0) {
    std::cout << "删除成功" << std::endl;
} else {
    std::cout << "键不存在" << std::endl;
}
```

### 5.2 通过迭代器删除

```cpp
auto it = word_count.find("banana");
if (it != word_count.end()) {
    word_count.erase(it);  // 不需要再次查找
    // 注意：删除后it失效，不能再使用
}
```

### 5.3 删除多个元素

```cpp
// 删除所有键以'a'开头的水果
for (auto it = word_count.begin(); it != word_count.end(); ) {
    if (it->first[0] == 'a') {
        it = word_count.erase(it);  // erase返回下一个有效迭代器
    } else {
        ++it;
    }
}
```

### 5.4 清空容器

```cpp
word_count.clear();  // 移除所有元素
```

## 6. 容量查询操作

### 6.1 检查是否为空

```cpp
if (word_count.empty()) {
    std::cout << "容器为空" << std::endl;
} else {
    std::cout << "容器不为空，有" << word_count.size() << "个元素" << std::endl;
}
```

### 6.2 获取元素数量

```cpp
size_t num_elements = word_count.size();
std::cout << "元素数量: " << num_elements << std::endl;
```

### 6.3 哈希表相关查询

```cpp
// 当前桶的数量
std::cout << "桶数量: " << word_count.bucket_count() << std::endl;

// 当前负载因子（元素数量/桶数量）
std::cout << "负载因子: " << word_count.load_factor() << std::endl;

// 最大负载因子
std::cout << "最大负载因子: " << word_count.max_load_factor() << std::endl;

// 查看特定键所在的桶
std::string key = "apple";
size_t bucket = word_count.bucket(key);
std::cout << key << "在桶#" << bucket << "中" << std::endl;
```

## 7. 迭代器操作

### 7.1 遍历所有元素

```cpp
// 方法1：范围for循环（C++11）
for (const auto& pair : word_count) {
    std::cout << pair.first << ": " << pair.second << std::endl;
}

// 方法2：使用迭代器
for (auto it = word_count.begin(); it != word_count.end(); ++it) {
    std::cout << it->first << ": " << it->second << std::endl;
}

// 方法3：使用常量迭代器
for (auto it = word_count.cbegin(); it != word_count.cend(); ++it) {
    // it->second = 10;  // 错误，不能修改
    std::cout << it->first << ": " << it->second << std::endl;
}
```

### 7.2 使用桶迭代器

```cpp
// 遍历所有桶
for (size_t i = 0; i < word_count.bucket_count(); ++i) {
    std::cout << "桶#" << i << "有" << word_count.bucket_size(i) << "个元素: ";
    
    // 遍历桶内元素
    for (auto it = word_count.begin(i); it != word_count.end(i); ++it) {
        std::cout << it->first << " ";
    }
    std::cout << std::endl;
}
```

## 实际示例：电话簿应用

```cpp
#include <iostream>
#include <unordered_map>
#include <string>

class PhoneBook {
private:
    std::unordered_map<std::string, std::string> contacts;
    
public:
    void addContact(const std::string& name, const std::string& number) {
        auto [iter, inserted] = contacts.emplace(name, number);
        if (!inserted) {
            std::cout << "联系人已存在，将更新号码" << std::endl;
            iter->second = number;
        }
    }
    
    bool removeContact(const std::string& name) {
        return contacts.erase(name) > 0;
    }
    
    void printContact(const std::string& name) const {
        auto it = contacts.find(name);
        if (it != contacts.end()) {
            std::cout << name << ": " << it->second << std::endl;
        } else {
            std::cout << "未找到联系人: " << name << std::endl;
        }
    }
    
    void listAllContacts() const {
        if (contacts.empty()) {
            std::cout << "电话簿为空" << std::endl;
            return;
        }
        
        std::cout << "所有联系人(" << contacts.size() << "):" << std::endl;
        for (const auto& [name, number] : contacts) {
            std::cout << "- " << name << ": " << number << std::endl;
        }
    }
};

int main() {
    PhoneBook pb;
    pb.addContact("Alice", "123456789");
    pb.addContact("Bob", "987654321");
    pb.addContact("Alice", "555555555");  // 更新Alice的号码
    
    pb.listAllContacts();
    pb.printContact("Bob");
    pb.printContact("Charlie");
    
    pb.removeContact("Bob");
    pb.listAllContacts();
    
    return 0;
}
```

## 关键注意事项

1. **键的唯一性**：`unordered_map` 中的键必须是唯一的，尝试插入相同键会失败（insert）或覆盖（[]操作符）。

2. **迭代器失效**：
   - 插入操作可能导致 rehash，使所有迭代器失效
   - 删除操作只使被删除元素的迭代器失效

3. **[]操作符的行为**：
   - 访问不存在的键会自动插入该键（值初始化）
   - 如果不希望自动插入，应该使用 find() 或 at()

4. **性能考虑**：
   - 预分配足够大的桶数量可以提高性能
   - 自定义类型的键需要提供良好的哈希函数

5. **线程安全**：
   - 标准 unordered_map 不是线程安全的
   - 多线程访问需要外部同步机制

通过以上详细讲解，你应该对 unordered_map 的基本操作有了全面的理解。实际编程中，根据具体需求选择合适的方法来操作 unordered_map，可以写出既高效又安全的代码。