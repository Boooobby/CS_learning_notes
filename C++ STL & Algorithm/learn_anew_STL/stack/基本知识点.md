# C++ 中的 Stack 详细学习指南

Stack（栈）是 C++ 标准模板库(STL)中的一个容器适配器，它遵循后进先出(LIFO)的原则。下面我将详细介绍 C++ 中 stack 的各个方面。

## 1. 基本概念

栈是一种限制性的线性数据结构，只允许在一端（称为栈顶）进行插入和删除操作。这种特性使得栈具有以下特点：
- 后进先出 (Last In First Out, LIFO)
- 只能访问栈顶元素
- 不支持随机访问

## 2. 头文件和声明

要使用 stack，需要包含 `<stack>` 头文件：

```cpp
#include <stack>
```

声明一个 stack 的基本语法：

```cpp
std::stack<T> stack_name;
```

其中 `T` 是存储在 stack 中的元素类型。

## 3. 底层容器

stack 是一个容器适配器，这意味着它是在其他序列容器（如 deque、list 或 vector）之上实现的。默认情况下，它使用 deque 作为底层容器：

```cpp
std::stack<int> s; // 默认使用 deque
```

你也可以显式指定底层容器：

```cpp
std::stack<int, std::vector<int>> s_vec; // 使用 vector 作为底层容器
std::stack<int, std::list<int>> s_list;  // 使用 list 作为底层容器
```

## 4. 常用成员函数

### 4.1 元素访问

- `top()`: 返回栈顶元素的引用

```cpp
std::stack<int> s;
s.push(10);
s.push(20);
std::cout << s.top(); // 输出 20
```

### 4.2 容量操作

- `empty()`: 检查栈是否为空
- `size()`: 返回栈中元素的数量

```cpp
if (s.empty()) {
    std::cout << "Stack is empty";
} else {
    std::cout << "Stack has " << s.size() << " elements";
}
```

### 4.3 修改器

- `push(const T& value)`: 将元素压入栈顶
- `push(T&& value)`: 移动元素到栈顶 (C++11)
- `emplace(args...)`: 在栈顶构造元素 (C++11)
- `pop()`: 移除栈顶元素
- `swap(stack& other)`: 交换两个栈的内容 (C++11)

```cpp
std::stack<int> s;
s.push(1);       // 压入1
s.emplace(2);    // 在栈顶构造2
s.pop();         // 移除2
```

## 5. 示例代码

```cpp
#include <iostream>
#include <stack>
#include <vector>

int main() {
    // 创建一个整数栈
    std::stack<int> s;
    
    // 压入元素
    s.push(10);
    s.push(20);
    s.push(30);
    
    // 显示栈大小
    std::cout << "Stack size: " << s.size() << std::endl;
    
    // 访问栈顶元素
    std::cout << "Top element: " << s.top() << std::endl;
    
    // 弹出元素
    s.pop();
    std::cout << "After pop, top element: " << s.top() << std::endl;
    
    // 使用 vector 作为底层容器
    std::stack<int, std::vector<int>> s_vec;
    s_vec.push(100);
    s_vec.push(200);
    
    // 交换两个栈
    s.swap(s_vec);
    
    // 显示交换后的栈内容
    std::cout << "After swap, s stack top: " << s.top() << std::endl;
    
    return 0;
}
```

## 6. 栈的应用场景

栈在编程中有广泛的应用，包括但不限于：
- 函数调用和递归
- 表达式求值和语法分析
- 括号匹配检查
- 深度优先搜索(DFS)
- 撤销(Undo)操作

## 7. 注意事项

1. **空栈访问**：在调用 `top()` 或 `pop()` 前，必须确保栈不为空，否则会导致未定义行为。
   
   ```cpp
   if (!s.empty()) {
       int val = s.top();
       s.pop();
   }
   ```

2. **性能考虑**：
   - 所有操作的时间复杂度都是 O(1)
   - 使用 vector 作为底层容器时，`push` 和 `pop` 可能涉及重新分配内存

3. **不支持迭代器**：stack 不提供迭代器，因此不能像其他容器那样遍历。

## 8. 自定义栈实现

理解栈的最好方式是自己实现一个简单的栈：

```cpp
template <typename T>
class MyStack {
private:
    std::vector<T> data;
public:
    void push(const T& value) {
        data.push_back(value);
    }
    
    void pop() {
        if (!empty()) {
            data.pop_back();
        }
    }
    
    T& top() {
        return data.back();
    }
    
    bool empty() const {
        return data.empty();
    }
    
    size_t size() const {
        return data.size();
    }
};
```

## 9. C++17 新增特性

C++17 引入了结构化绑定，可以与 stack 一起使用（虽然 stack 本身没有变化）：

```cpp
std::stack<std::pair<int, std::string>> s;
s.emplace(1, "one");
s.emplace(2, "two");

auto [num, str] = s.top(); // 结构化绑定
std::cout << num << ": " << str << std::endl;
```

希望这份详细的指南能帮助你全面理解 C++ 中的 stack。如果需要更深入的了解某个特定方面，可以进一步探讨。