# queue

### **队列（Queue）简介**

**队列（Queue）** 是一种 **先进先出**（FIFO, First In First Out）的数据结构。也就是说，**先进入队列的元素最先被移出**，就像排队买票一样，最先排队的人最先得到服务。

### **队列的特点**
- **先进先出（FIFO）**：最先入队的元素最先出队。
- **双端操作**：通常只有队列的两端（队头和队尾）可进行操作。队尾用于插入元素，队头用于删除元素。
- **不允许直接访问队中间的元素**，只能访问队头和队尾。

### **队列的常用操作**

1. **入队（Enqueue）**：
   - 向队尾插入一个元素。

2. **出队（Dequeue）**：
   - 移除队头的元素，并返回该元素。

3. **查看队头（Front）**：
   - 返回队头的元素，但不移除它。

4. **查看队尾（Back）**：
   - 返回队尾的元素，但不移除它。

5. **判断队列是否为空（Empty）**：
   - 检查队列是否为空。

6. **获取队列的大小（Size）**：
   - 返回队列中元素的数量。

### **队列的操作复杂度**
队列的操作通常具有 **常数时间复杂度** \( O(1) \)，具体操作如下：

- **入队（Enqueue）**: \( O(1) \)
- **出队（Dequeue）**: \( O(1) \)
- **查看队头（Front）**: \( O(1) \)
- **查看队尾（Back）**: \( O(1) \)
- **判断队列是否为空（Empty）**: \( O(1) \)
- **获取队列大小（Size）**: \( O(1) \)

### **C++ 中的 `queue` 库**
在 C++ 中，`queue` 是 **STL（标准模板库）** 提供的一个容器适配器，默认使用 **`deque`** 或 **`list`** 作为底层容器。

#### **头文件**
```cpp
#include <queue>
```

#### **常用操作**
| **函数/方法**       | **作用**                                                              |
|---------------------|-----------------------------------------------------------------------|
| `push(value)`       | 将元素插入队尾。                                                     |
| `pop()`             | 移除队头元素。                                                       |
| `front()`           | 获取队头元素（不移除）。                                             |
| `back()`            | 获取队尾元素（不移除）。                                             |
| `empty()`           | 判断队列是否为空。                                                   |
| `size()`            | 获取队列的大小。                                                     |
| `swap(otherQueue)`  | 交换两个队列的内容。                                                 |

---

### **队列的基本用法示例**

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> q;

    // 入队
    q.push(10);
    q.push(20);
    q.push(30);

    // 获取队头元素
    cout << "队头元素: " << q.front() << endl; // 输出 10

    // 获取队尾元素
    cout << "队尾元素: " << q.back() << endl; // 输出 30

    // 获取队列大小
    cout << "队列大小: " << q.size() << endl; // 输出 3

    // 出队
    q.pop();
    cout << "队头元素（出队后）: " << q.front() << endl; // 输出 20

    // 判断队列是否为空
    if (q.empty()) {
        cout << "队列为空" << endl;
    } else {
        cout << "队列不为空" << endl; // 输出 "队列不为空"
    }

    return 0;
}
```

### **`queue` 底层容器**
默认情况下，`std::queue` 使用 **`deque`**（双端队列）作为底层容器，但你也可以显式指定使用其他容器，如 `list` 或其他符合队列接口的容器。

#### **使用 `deque` 作为底层容器**
```cpp
#include <iostream>
#include <queue>
#include <deque>
using namespace std;

int main() {
    queue<int, deque<int>> q;  // 显式使用 deque 作为底层容器

    q.push(1);
    q.push(2);
    q.push(3);

    while (!q.empty()) {
        cout << q.front() << " "; // 输出 1 2 3
        q.pop();
    }

    return 0;
}
```

#### **使用 `list` 作为底层容器**
```cpp
#include <iostream>
#include <queue>
#include <list>
using namespace std;

int main() {
    queue<int, list<int>> q;  // 显式使用 list 作为底层容器

    q.push(10);
    q.push(20);
    q.push(30);

    while (!q.empty()) {
        cout << q.front() << " "; // 输出 10 20 30
        q.pop();
    }

    return 0;
}
```

### **队列的常见应用**

1. **任务调度**：
   - 用于管理任务的执行顺序，例如操作系统的任务调度。
   
2. **广度优先搜索（BFS）**：
   - 在图形和树的遍历中，广度优先搜索（BFS）使用队列来保证按层次顺序访问节点。

3. **缓存管理**：
   - 用于实现 **先进先出** 缓存策略（FIFO 缓存），如页面替换算法中的队列实现。

4. **生产者-消费者问题**：
   - 在多线程编程中，生产者线程将数据放入队列，消费者线程从队列中取出数据进行处理。

---

### **总结**
- **队列（Queue）** 是一种 **先进先出（FIFO）** 的数据结构，适合处理按顺序的任务或数据。
- 在 C++ 中，`std::queue` 提供了高效的队列操作，基于 **`deque`** 或 **`list`** 实现。
- 通过常用操作如 `push()`、`pop()`、`front()`、`back()` 和 `size()`，可以轻松管理和访问队列中的数据。