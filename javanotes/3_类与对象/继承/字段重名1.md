### **Java 继承中字段重名的问题**  

当子类和父类定义了**同名字段**时，Java 的处理规则如下：

---

## **1. 字段不会覆盖（No Overriding）**
- **字段（成员变量）没有多态**，即使子类声明了和父类同名的字段，**父类的字段依然存在**。  
- 子类的字段只是“隐藏”（Shadow）了父类的字段，两者**同时存在**，具体访问哪个取决于引用类型。  

### **示例代码**
```java
class Parent {
    String name = "Parent";
}

class Child extends Parent {
    String name = "Child"; // 与父类同名字段
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        System.out.println(child.name); // 输出: Child（子类字段）
        
        Parent parent = child; // 向上转型
        System.out.println(parent.name); // 输出: Parent（父类字段）
    }
}
```
**输出**：
```
Child
Parent
```

### **关键点**
- **`child.name`**：访问的是子类的 `name`。  
- **`parent.name`**：虽然 `parent` 指向 `Child` 对象，但由于字段没有多态，访问的是父类的 `name`。  

---

## **2. 如何访问被隐藏的父类字段？**
如果需要在子类中访问父类的同名字段，可以用 **`super`**：
```java
class Child extends Parent {
    String name = "Child";

    void printNames() {
        System.out.println(name);       // 子类的 name（"Child"）
        System.out.println(super.name); // 父类的 name（"Parent"）
    }
}
```

---

## **3. 静态字段（Static Field）的重名**
静态字段同样遵循“隐藏”规则，但访问方式取决于**引用类型**（不是运行时类型）：
```java
class Parent {
    static String className = "Parent";
}

class Child extends Parent {
    static String className = "Child";
}

public class Main {
    public static void main(String[] args) {
        System.out.println(Child.className); // "Child"
        System.out.println(Parent.className); // "Parent"

        Parent obj = new Child();
        System.out.println(obj.className); // "Parent"（取决于引用类型，不是运行时类型）
    }
}
```

---

## **4. 字段 vs 方法重写（重要区别）**
|  | **字段（Field）** | **方法（Method）** |
|---|---|---|
| **重名时的行为** | 隐藏（Shadowing） | 重写（Overriding） |
| **多态性** | ❌ 无多态，访问取决于引用类型 | ✔️ 有动态绑定，取决于运行时类型 |
| **如何访问父类成员** | `super.field` | `super.method()` |

### **示例对比**
```java
class Parent {
    String name = "Parent";
    void printName() {
        System.out.println(name);
    }
}

class Child extends Parent {
    String name = "Child"; // 隐藏父类字段
    @Override
    void printName() {
        System.out.println(name); // 方法重写，动态绑定
    }
}

public class Main {
    public static void main(String[] args) {
        Parent obj = new Child();
        System.out.println(obj.name); // "Parent"（字段无多态）
        obj.printName(); // "Child"（方法有多态）
    }
}
```
**输出**：
```
Parent
Child
```

---

## **5. 最佳实践**
1. **避免字段重名**：容易引起混淆，建议子类字段用不同名称。  
2. **如果必须重名**：  
   - 用 `super` 访问父类字段。  
   - 方法可以重写，但字段不会覆盖。  
3. **静态字段**：尽量不要在子类中定义同名静态字段，容易导致逻辑混乱。  

---

## **总结**
- **字段重名 = 隐藏（Shadowing）**，父类和子类的字段**同时存在**。  
- **访问哪个字段取决于引用类型**（不是运行时类型）。  
- **方法重写（Override） vs 字段隐藏（Shadow）**：  
  - 方法：动态绑定，运行时决定调用哪个。  
  - 字段：静态绑定，编译时决定访问哪个。  
- **用 `super` 访问父类字段**，避免歧义。  

这样设计是为了保持**字段访问的明确性**，而方法重写是为了支持**多态**。