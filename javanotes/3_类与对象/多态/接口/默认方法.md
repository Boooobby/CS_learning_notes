# Java接口的默认方法详解

Java 8引入了一个重要的新特性：接口的**默认方法**(Default Methods)，也称为**防御方法**或**虚拟扩展方法**。这一特性为接口添加了方法实现的能力，改变了接口只能定义抽象方法的传统。

## 什么是默认方法

默认方法是接口中使用`default`关键字修饰的**非抽象方法**，它提供了默认实现：

```java
public interface Vehicle {
    // 传统抽象方法
    void start();
    
    // 默认方法
    default void stop() {
        System.out.println("Vehicle stopped");
    }
}
```

## 为什么需要默认方法

1. **向后兼容性**：当需要向现有接口添加新方法时，如果不提供默认实现，所有实现该接口的类都需要修改

2. **减少抽象类的使用**：以前需要通过抽象类提供部分实现，现在可以直接在接口中实现

3. **支持函数式编程**：为Java 8的Lambda表达式和Stream API提供了基础

## 默认方法的特点

1. **实现类可以继承或重写**：
   ```java
   public class Car implements Vehicle {
       @Override
       public void start() {
           System.out.println("Car started");
       }
       
       // 可以选择不实现stop()方法，使用默认实现
   }
   ```

2. **可以调用其他方法**：
   ```java
   interface Calculator {
       default int add(int a, int b) {
           return a + b;
       }
       
       default int multiply(int a, int b) {
           return a * b;
       }
       
       default int addThenMultiply(int a, int b, int c) {
           return multiply(add(a, b), c);
       }
   }
   ```

3. **可以访问接口的静态方法**：
   ```java
   interface TimeUtils {
       static LocalTime now() {
           return LocalTime.now();
       }
       
       default String currentTime() {
           return "Current time: " + now();
       }
   }
   ```

## 多重继承问题

当类实现多个接口且这些接口有相同签名的默认方法时，会出现冲突：

```java
interface A {
    default void foo() {
        System.out.println("A.foo");
    }
}

interface B {
    default void foo() {
        System.out.println("B.foo");
    }
}

class C implements A, B {  // 编译错误
}
```

解决方法：
1. **显式重写**：
   ```java
   class C implements A, B {
       @Override
       public void foo() {
           System.out.println("C.foo");
       }
   }
   ```

2. **指定使用哪个接口的默认方法**：
   ```java
   class C implements A, B {
       @Override
       public void foo() {
           A.super.foo();  // 显式调用A接口的默认方法
       }
   }
   ```

## 默认方法与抽象类的区别

| 特性                | 默认方法(接口)       | 抽象类               |
|---------------------|---------------------|----------------------|
| 多继承              | 支持                | 不支持               |
| 状态(字段)          | 不能有实例字段      | 可以有实例字段       |
| 构造方法            | 不能有              | 可以有               |
| 方法实现            | Java 8+支持默认方法 | 一直支持             |
| 访问修饰符          | 默认public          | 可以是任意修饰符     |

## 实际应用示例

Java集合框架中大量使用了默认方法，例如`List`接口：

```java
default void sort(Comparator<? super E> c) {
    Collections.sort(this, c);
}

default Spliterator<E> spliterator() {
    return Spliterators.spliterator(this, Spliterator.ORDERED);
}
```

这些默认方法使得所有List实现类自动获得了排序和分割迭代的能力，而无需每个实现类都自行实现。

## 最佳实践

1. 谨慎使用默认方法，主要用于维护向后兼容性
2. 避免在默认方法中定义业务逻辑，保持其简单性
3. 当多个接口有相同默认方法时，确保实现类正确处理冲突
4. 考虑使用`@FunctionalInterface`注解标记函数式接口

默认方法是Java向更灵活的接口设计迈出的重要一步，它平衡了接口的抽象性和实用性。