# 适配器模式（Adapter Pattern）详解

适配器模式是一种**结构型设计模式**，它允许**不兼容的接口之间能够协同工作**，就像现实世界中的电源适配器让不同标准的插头能够插入插座一样。

## 核心概念

适配器模式通过一个**中间层（适配器）**将一个类的接口转换成客户端期望的另一种接口，解决接口不兼容问题。

### 三种角色：
1. **目标接口（Target）**：客户端期望使用的接口
2. **被适配者（Adaptee）**：需要被适配的现有组件
3. **适配器（Adapter）**：实现目标接口并包装被适配者的中间件

## 两种实现方式

### 1. 类适配器（通过继承实现）

```java
// 目标接口
interface USB {
    void connect();
}

// 被适配者
class TypeC {
    public void typeCConnect() {
        System.out.println("Type-C连接");
    }
}

// 适配器（继承被适配者）
class TypeCToUSBAdapter extends TypeC implements USB {
    @Override
    public void connect() {
        super.typeCConnect(); // 调用父类方法
    }
}

// 使用
USB usb = new TypeCToUSBAdapter();
usb.connect(); // 输出：Type-C连接
```

### 2. 对象适配器（通过组合实现 - 更推荐）

```java
// 目标接口
interface USB {
    void connect();
}

// 被适配者
class TypeC {
    public void typeCConnect() {
        System.out.println("Type-C连接");
    }
}

// 适配器（组合被适配者）
class TypeCToUSBAdapter implements USB {
    private TypeC typeC;
    
    public TypeCToUSBAdapter(TypeC typeC) {
        this.typeC = typeC;
    }
    
    @Override
    public void connect() {
        typeC.typeCConnect();
    }
}

// 使用
TypeC typeC = new TypeC();
USB usb = new TypeCToUSBAdapter(typeC);
usb.connect(); // 输出：Type-C连接
```

## 实际应用场景

1. **旧系统整合**：将遗留代码适配到新系统
   ```java
   // 旧版日志接口
   class LegacyLogger {
       public void logMessage(String message) {
           System.out.println("Legacy: " + message);
       }
   }
   
   // 新版日志接口
   interface ModernLogger {
       void log(String msg, String level);
   }
   
   // 适配器
   class LoggerAdapter implements ModernLogger {
       private LegacyLogger legacyLogger;
       
       public LoggerAdapter(LegacyLogger logger) {
           this.legacyLogger = logger;
       }
       
       @Override
       public void log(String msg, String level) {
           legacyLogger.logMessage("[" + level + "] " + msg);
       }
   }
   ```

2. **第三方库适配**：统一不同库的接口
   ```java
   // 支付网关A的接口
   class PaymentGatewayA {
       public void makePayment(double amount) {
           System.out.println("使用GatewayA支付: " + amount);
       }
   }
   
   // 统一支付接口
   interface UnifiedPayment {
       void pay(double amount);
   }
   
   // 适配器
   class GatewayAAdapter implements UnifiedPayment {
       private PaymentGatewayA gatewayA;
       
       public GatewayAAdapter(PaymentGatewayA gateway) {
           this.gatewayA = gateway;
       }
       
       @Override
       public void pay(double amount) {
           gatewayA.makePayment(amount);
       }
   }
   ```

3. **数据格式转换**：如XML到JSON的适配
   ```java
   interface JSONParser {
       void parseJSON(String json);
   }
   
   class XMLParser {
       public void parseXML(String xml) {
           System.out.println("解析XML: " + xml);
       }
   }
   
   class XMLToJSONAdapter implements JSONParser {
       private XMLParser xmlParser;
       
       public XMLToJSONAdapter(XMLParser parser) {
           this.xmlParser = parser;
       }
       
       @Override
       public void parseJSON(String json) {
           String xml = convertJSONtoXML(json);
           xmlParser.parseXML(xml);
       }
       
       private String convertJSONtoXML(String json) {
           // 简化的转换逻辑
           return json.replace("{", "<").replace("}", ">");
       }
   }
   ```

## 适配器模式的优势

1. **解耦客户端与被适配者**：客户端只依赖目标接口
2. **复用现有类**：无需修改原有代码就能整合新功能
3. **符合开闭原则**：通过新增适配器类来扩展功能
4. **灵活性高**：可以适配多个不同的被适配者

## 与相关模式对比

| 模式        | 目的                               | 关键区别                     |
|------------|-----------------------------------|----------------------------|
| 适配器模式   | 转换接口使能协同工作               | 关注接口兼容性              |
| 装饰器模式   | 动态添加功能                       | 关注功能增强，接口不变       |
| 外观模式     | 简化复杂系统的接口                 | 提供更高级的统一接口         |
| 代理模式     | 控制对对象的访问                   | 保持相同接口，控制访问行为   |

## 最佳实践

1. **优先使用对象适配器**（组合优于继承）
2. **保持适配器单一职责**：一个适配器只适配一个被适配者
3. **考虑接口稳定性**：如果目标接口经常变化，适配器可能不适用
4. **不要过度使用**：系统内过多适配器会增加复杂度

## Java标准库中的例子

1. **集合适配器**：
   ```java
   String[] array = {"A", "B", "C"};
   List<String> list = Arrays.asList(array); // 数组到List的适配
   ```

2. **IO流适配器**：
   ```java
   InputStream is = new FileInputStream("file.txt");
   Reader reader = new InputStreamReader(is); // 字节流到字符流的适配
   ```

适配器模式是处理遗留代码、整合第三方库时的利器，它能有效降低系统各部分之间的耦合度，提高代码的复用性和灵活性。

---

---

# 适配器模式：就像转接头一样简单！

让我用一个生活中超级常见的例子帮你彻底理解适配器模式。

## 现实生活中的适配器

想象你从日本买了个电饭煲（日本电器是110V电压），但中国的插座是220V的。这时候你需要什么？

🔌 **电源适配器（变压器）**！它做了三件事：
1. 接受中国的220V输入（目标接口）
2. 内部转换成110V（适配过程）
3. 输出给日本电饭煲使用（被适配者）

## 代码世界的同样问题

假设我们有一个老式MP3播放器（被适配者），但新时代的手机（客户端）想用统一接口控制它：

```java
// 老式MP3播放器（像日本电饭煲）
class OldMP3 {
    public void playMusic() {
        System.out.println("播放老式MP3音乐...");
    }
}

// 新时代智能设备接口（像中国插座）
interface SmartDevice {
    void play(); // 统一播放方法
}

// 适配器（像电源转换器）
class MP3Adapter implements SmartDevice {
    private OldMP3 oldMP3;  // 装入老设备
    
    public MP3Adapter(OldMP3 mp3) {
        this.oldMP3 = mp3;
    }
    
    @Override
    public void play() {  // 统一接口方法
        oldMP3.playMusic(); // 内部调用老设备的方法
    }
}
```

## 怎么使用？

```java
public class Test {
    public static void main(String[] args) {
        // 老设备
        OldMP3 walkman = new OldMP3();
        
        // 新设备通过适配器使用老设备
        SmartDevice device = new MP3Adapter(walkman);
        
        device.play();  // 输出：播放老式MP3音乐...
    }
}
```

## 关键点比喻

| 概念         | 现实例子              | 代码对应                |
|-------------|----------------------|------------------------|
| 目标接口     | 中国插座标准          | `SmartDevice` 接口     |
| 被适配者     | 日本电饭煲            | `OldMP3` 类           |
| 适配器       | 电压转换器            | `MP3Adapter` 类       |
| 客户端       | 使用电器的人          | `main()` 方法中的调用 |

## 另一个生动例子：读卡器

你相机里的SD卡（被适配者）不能直接插到USB接口（目标接口）上，怎么办？

📸 **使用读卡器（适配器）**：
1. 读卡器实现USB接口
2. 内部可以插入SD卡
3. 电脑通过USB接口读写SD卡

```java
// SD卡（被适配者）
class SDCard {
    public String readData() {
        return "SD卡中的数据";
    }
}

// USB接口（目标接口）
interface USB {
    String getData();
}

// 读卡器（适配器）
class CardReader implements USB {
    private SDCard sdCard;
    
    public CardReader(SDCard card) {
        this.sdCard = card;
    }
    
    @Override
    public String getData() {
        return sdCard.readData(); // 转换调用
    }
}

// 使用
SDCard card = new SDCard();
USB usb = new CardReader(card);
System.out.println(usb.getData()); // 输出：SD卡中的数据
```

## 为什么需要适配器？

1. **不修改老代码**：不用改SD卡和USB接口的设计
2. **统一接口**：所有存储设备都通过USB接口访问
3. **灵活扩展**：未来可以轻松支持其他存储卡类型

## 总结一句话

适配器模式就是：**让两个不兼容的东西能够一起工作，而且不用改动它们原来的设计**，就像给老设备装了个转接头！